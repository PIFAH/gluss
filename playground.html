<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>gluss playground</title>
        <style>
            html, body {
                width: 100%;
                height: 100%;
                margin:0;
                padding:0;
                overflow: hidden;
            }
        </style>

  </head>
    <body>
    <div id="world"></div>
    <div id="control">
    <textarea id="cli" rows="8" cols="80">
    Imagine enterring a command here.
    </textarea>
    <button type="button" onclick="execute_code(this)">
    Execute    
</button>
    
    <textarea id="pmodel" rows="8" cols="80">
    The physcial model positions as JSON object will be rendered here.
    </textarea>
        
    <button type="button" onclick="render_physical_model(this)">
    Render Physical    
</button>
        <textarea id="amodel" rows="8" cols="80">
    The physcial model positions as JSON object will be rendered here.
    </textarea>
    <button type="button" onclick="render_actuator_model()">
    Render Actual
</button>
    
</button>

<div>
    <button type="button" onclick="double_size()">
    Double size
</button>
    <button type="button" onclick="half_size()">
Half size
</button>
    <button type="button" onclick="flat()">
Flat Pose
</button>

    <button type="button" onclick="regenerate()">
    Regenerate
</button>
</div>


    

    </div>
    
        <script src="./js/three.js"></script>
        <script src="./js/Detector.js"></script>
    <script src="./js/cannon.js"></script>
    	<script src="./js/Projector.js"></script>	
    <script src="./js/STLLoader.js"></script>
    <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>    
 //   <script src="./js/d3-scale.min.js"></script>
 //   <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>

<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="https://d3js.org/d3-collection.v1.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-format.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-time.v1.min.js"></script>
<script src="https://d3js.org/d3-time-format.v2.min.js"></script>
<script src="https://d3js.org/d3-scale.v1.min.js"></script>

    
    <script src="./js/OrbitControls.js"></script>
     <script type="text/javascript" src="./js/dat.gui.js"></script> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
    <script>


// A "robot" is really a graph of vertices with connections.
// In physical realization, the connections are actuators with length limits.
// In our first implementation, we will treat this as a set of springs in
// the cannon.js world...
// So in a sense we have 3 virtual worlds here: the abstract world
// of the robot, the cannon.js world of almost-physical objects, and
// the three.js world of meshes.
// This will be made slightly more confusing by utilizing Three.js
// and cannon.js utility classes (such as Vector) for convenience,
// even in the abstract world of the robot space.


// TODO: I hate global variables ---- I'd like to encapsulate this
// into a class.

var MirroredWorld = function() {
    this.dt = 1/60;
};

var mirroredWorld = new MirroredWorld();
var world;
// var dt = 1 / 60;

var constraintDown = false;
var camera, cameraOrtho, scene, sceneOrtho, renderer, gplane=false, clickMarker=false;
var geometry, material, mesh;
var controls,time = Date.now();

var MARGIN = 0;
var SCREEN_WIDTH = window.innerWidth;
var SCREEN_HEIGHT = 2*window.innerHeight/3.0;


// These are in meters, measured joint-center to joint-center
var MAX_EDGE_LENGTH = 0.460;
var MIN_EDGE_LENGTH = 0.340;
var MEDIAN_EDGE_LENGTH = (MAX_EDGE_LENGTH + MIN_EDGE_LENGTH)/2;
var JOINT_RADIUS = 0.0508 / 2; // This is the 2" ball.

var INITIAL_HEIGHT = 0.5;


var jointBody, constrainedBody, mouseConstraint;

var container, camera, scene, renderer, projector;

var meshes=[], bodies=[];


var NUMBER_OF_TETRAHEDRA = 3;

// This is where the cannon.js joints are storied
var robot_joints = [];
// This is the cannon.js robot members.
var robot_members = [];
// This is a map of the robot links.
// var links_map = [];

var getTexture = function () {
    var texture = new THREE.TextureLoader("./logo-tight.png");
    return texture;
}

function push_body_mesh_pair(body,mesh) {
    meshes.push(mesh);
    bodies.push(body);
}

function create_box(world,scene,i) {
    var mass = 5, radius = 1.3;
    boxShape = new CANNON.Sphere(JOINT_RADIUS);
    boxBody = new CANNON.Body({ mass: mass });
    boxBody.addShape(boxShape);
    boxBody.position.set(0,N,0);
    boxBody.angularDamping = 0.9;
    boxBody.linearDamping = 0.9;
    world.add(boxBody);

    // The mesh stuff
    var sphereGeo = new THREE.SphereGeometry( JOINT_RADIUS, 32, 32 );
    var cubeMaterial = new THREE.MeshPhongMaterial( { color: 0x888888 } );
    
    var cubeMesh = new THREE.Mesh(cubeGeo, cubeMaterial);
    cubeMesh.castShadow = true;
    scene.add(cubeMesh);
    return [boxBody,cubeMesh];
}

function create_boxes(world,scene) {
    var cubeGeo = new THREE.SphereGeometry( JOINT_RADIUS, 32, 32 );
    var cubeMaterial = new THREE.MeshPhongMaterial( { color: 0x888888 } );

    for(var i=0; i<N; i++){
	var pair = create_box(world,scene,i);
	push_body_mesh_pair(pair[0],pair[1]);
    }
}

function establish_controls(camera,container) {
    controls = new THREE.OrbitControls( camera, container );
    //controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;
    controls.enabled = true;

}
function init_scene() {
    projector = new THREE.Projector();
    var world_container = $("#world");
    
    container = document.createElement( 'div' );
    
    world_container.append( container );

    container.style["max-height"] = 800;

    container.style.backgroundColor = "blue";

    // scene
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog( 0x000000, 500, 10000 );

    sceneOrtho = new THREE.Scene();

    //
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setClearColor( scene.fog.color );
    // After we do this, we want to start using renderer.getSize.
    renderer.setSize( window.innerWidth,  window.innerHeight*2/3  );    

    // camera
    camera = new THREE.PerspectiveCamera( 35, renderer.getSize().width / (renderer.getSize().height), 0.5, 10000 );
    camera.position.set(3, 1, 0);
    var origin = new THREE.Vector3(0,0,0);
    camera.lookAt(origin);
    camera.quaternion.setFromAxisAngle(new THREE.Vector3(0,1,0), (Math.PI/2));

    cameraOrtho = new THREE.OrthographicCamera( 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, - 10, 10 );

    establish_controls(camera,container);
    
    scene.add(camera);

    // lights
    var light, materials;
    scene.add( new THREE.AmbientLight( 0x666666 ) );


    scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );
    addShadowedLight( 1, 1, 1, 0xffffff, 1.35 );
    addShadowedLight( 0.5, 1, -1, 0xffaa00, 1 );
    
    light = new THREE.DirectionalLight( 0xffffff, 1.75 );
    var d = 200;

    light.position.set( d, d, d );

    light.castShadow = true;
    light.shadow.CameraVisible = true;

    light.shadow.MapWidth = 1024;
    light.shadow.MapHeight = 1024;

    light.shadow.CameraLeft = -d;
    light.shadow.CameraRight = d;
    light.shadow.CameraTop = d;
    light.shadow.CameraBottom = -d;

    light.shadow.CameraFar = 3*d;
    light.shadow.CameraNear = d;
    light.shadow.Darkness = 0.5;

    light = new THREE.DirectionalLight( 0xffffff, 1.75 );
    var d = 20;

    light.position.set( -d, d, -d );

    light.castShadow = true;
    //light.shadow.CameraVisible = true;

    light.shadow.MapWidth = 1024;
    light.shadow.MapHeight = 1024;

    light.shadow.CameraLeft = -d;
    light.shadow.CameraRight = d;
    light.shadow.CameraTop = d;
    light.shadow.CameraBottom = -d;

    light.shadow.CameraFar = 3*d;
    light.shadow.CameraNear = d;
    light.shadow.Darkness = 0.5;

    scene.add( light );

    return scene;
}

function addShadowedLight( x, y, z, color, intensity ) {
    var directionalLight = new THREE.DirectionalLight( color, intensity );
    directionalLight.position.set( x, y, z );
    scene.add( directionalLight );
    directionalLight.castShadow = true;
    var d = 1;
    directionalLight.shadow.camera.left = -d;
    directionalLight.shadow.camera.right = d;
    directionalLight.shadow.camera.top = d;
    directionalLight.shadow.camera.bottom = -d;
    directionalLight.shadow.camera.near = 1;
    directionalLight.shadow.camera.far = 4;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.bias = -0.005;
}


// This needs to be changed to init the floor and ground together...
function finish_scene_preparation(schen) {
    material = new THREE.MeshLambertMaterial( { color: 0x777777 } );
    markerMaterial = new THREE.MeshLambertMaterial( { color: 0xff0000 } );
    container.appendChild( renderer.domElement );
    
    renderer.gammaInput = true;
    renderer.gammaOutput = true;
    renderer.shadowMap.Enabled = true;

    window.addEventListener( 'resize', onWindowResize, false );

    window.addEventListener("mousemove", onMouseMove, false );
    window.addEventListener("mousedown", onMouseDown, false );
    window.addEventListener("mouseup", onMouseUp, false );
}

function setClickMarker(x,y,z) {
    if(!clickMarker){
        var shape = new THREE.SphereGeometry(JOINT_RADIUS/4, 8, 8);
        clickMarker = new THREE.Mesh(shape, markerMaterial);
        scene.add(clickMarker);
    }
    clickMarker.visible = true;
    clickMarker.position.set(x,y,z);
}

function removeClickMarker(){
    clickMarker.visible = false;
}

function onMouseMove(e){
    // Move and project on the plane
    if (gplane && mouseConstraint) {

	var mouse3D = new THREE.Vector3( ( event.clientX / renderer.getSize().width ) * 2 - 1,   //x
					 -( event.clientY / (renderer.getSize().height) ) * 2 + 1,  //y
					 0.5 );                                            //z
	
	mouse3D.unproject( camera );

        var pos = projectOntoPlane(e.clientX,e.clientY,gplane,camera);
        if(pos){
            setClickMarker(pos.x,pos.y,pos.z,scene);
            moveJointToPoint(pos.x,pos.y,pos.z);
        }
    }
}

function onMouseDown(e){
    // Find mesh from a ray
    console.log(e); // you can inspect the click event

    var mouse3D = new THREE.Vector3( ( e.clientX / renderer.getSize().width ) * 2 - 1,   //x
				     -( e.clientY / (renderer.getSize().height) ) * 2 + 1,  //y
				     0.5 );                                            //z
    mouse3D.unproject( camera );
    mouse3D.sub(camera.position);
    mouse3D.project( camera );
    
    var entity = findNearestIntersectingObject(e.clientX,e.clientY,camera,meshes);
    var pos = entity.point;
    if(pos && entity.object.geometry instanceof THREE.SphereGeometry){
        constraintDown = true;
        // Set marker on contact point
        setClickMarker(pos.x,pos.y,pos.z,scene);

        // Set the movement plane
        setScreenPerpCenter(pos,camera);

        var idx = meshes.indexOf(entity.object);
        if(idx !== -1){
            addMouseConstraint(pos.x,pos.y,pos.z,bodies[idx]);
        }
    }
}

// This function creates a virtual movement plane for the mouseJoint to move in
function setScreenPerpCenter(point, camera) {
    // If it does not exist, create a new one
    if(!gplane) {
	// We need to be precese about what these coordinates are!
        var planeGeo = new THREE.PlaneGeometry(4000,4000);
	// Something has change in three.js, apparently ray casting only
	// works with visible objects.  Since we are creating a plan to
	// move the joint in, I am going to try to create an object here that makes since.
	var plane_material = new THREE.MeshLambertMaterial( { color: 0x110000 } );
	plane_material.transparent = true;
	plane_material.opacity = 0.0;
	
        var plane = gplane = new THREE.Mesh(planeGeo,plane_material);
	//        plane.visible = false; // Hide it..
	// ????
	
        scene.add(gplane);
    }
    gplane.visible = true;
    gplane.name = "movementplane";
    controls.enabled = false;

    // Center at mouse position
    gplane.position.copy(point);

    // Make it face toward the camera
    gplane.quaternion.copy(camera.quaternion);
}

function onMouseUp(e) {
    constraintDown = false;
    // remove the marker
    removeClickMarker();

    // Send the remove mouse joint to server
    removeJointConstraint();

    if (gplane.visible == true) {
	gplane.visible = false;
	// We need to re-establish the controls because I don't have
	// any good way of exiting the active state...
	controls.dispose();
	establish_controls(camera,container);
    }

}

var lastx,lasty,last;
function projectOntoPlane(screenX,screenY,thePlane,camera) {
    var x = screenX;
    var y = screenY;
    var now = new Date().getTime();
    // project mouse to that plane
    // This is probably highly wrong...
    // this means that we can only fold an object on itself.
    // I think this would work if you have
    var hit = findNearestIntersectingObject(screenX,screenY,camera,[thePlane]);
    lastx = x;
    lasty = y;
    last = now;
    if(hit)
        return hit.point;
    return false;
}
function findNearestIntersectingObject(clientX,clientY,camera,objects) {
    var mouse3D = new THREE.Vector3( ( event.clientX / renderer.getSize().width ) * 2 - 1,   //x
                                     -( event.clientY / (renderer.getSize().height) ) * 2 + 1,  //y
                                     0.5 );                                            //z
    
    var mouse = new THREE.Vector2();
    mouse.x = (event.clientX / renderer.getSize().width) * 2 - 1;
    mouse.y = -(event.clientY / (renderer.getSize().height)) * 2 + 1; 

    var raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects( objects );        
    // Change color if hit block
    if ( intersects.length > 0 ) {
	if (intersects[0].object.name != "movementplane") 
	    intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
    }
    var closest = false;
    if (intersects.length > 0) {
        closest = intersects[0];
    }

    return closest;
}

// Function that returns a raycaster to use to find intersecting objects
// in a scene given screen pos and a camera, and a projector
function getRayCasterFromScreenCoord (screenX, screenY, camera, projector) {
    var mouse3D = new THREE.Vector3();
    // Get 3D point form the client x y
    mouse3D.x = (screenX / renderer.getSize().width) * 2 - 1;
    mouse3D.y = -(screenY / renderer.getSize().height) * 2 + 1;
    mouse3D.z = 0.5;
    return projector.pickingRay(mouse3D, camera);
}

function onWindowResize() {
    renderer.setSize( window.innerWidth, (2*window.innerHeight)/3 );
    
    camera.updateProjectionMatrix();

    SCREEN_WIDTH = renderer.getSize().width;
    SCREEN_HEIGHT = renderer.getSize().height;
    camera.radius = ( SCREEN_WIDTH + SCREEN_HEIGHT ) / 4;

    cameraOrtho = new THREE.OrthographicCamera( 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, - 10, 10 );
}

function animate() {
    requestAnimationFrame( animate );
    //    controls.update();
    updatePhysics();    
    render();
}

var cylinderMesh = function( pointX, pointY )
{
    // edge from X to Y
    var direction = new THREE.Vector3().subVectors( pointY, pointX );
    var arrow = new THREE.ArrowHelper( direction, pointX );

    var edgeGeometry = new THREE.CylinderGeometry( 2, 2, direction.length(), 6, 4 );

    var edge = new THREE.Mesh( edgeGeometry, 
			       new THREE.MeshBasicMaterial( { color: 0xff00ff } ) );
    edge.rotation = arrow.rotation.clone();
    edge.position = new THREE.Vector3().addVectors( pointX, direction.multiplyScalar(0.5) );
    return edge;
}

// orientMesh from X to Y at Midpoint
function orientMesh( mesh, pointX, pointY )
{
    // edge from X to Y
    var direction = new THREE.Vector3().subVectors( pointY, pointX );
    var arrow = new THREE.ArrowHelper( direction, pointX );

    // cylinder: radiusAtTop, radiusAtBottom, 
    //     height, radiusSegments, heightSegments
    var edgeGeometry = new THREE.CylinderGeometry( 2, 2, direction.length(), 6, 4 );

    //     var edge = new THREE.Mesh( edgeGeometry, 
    //        new THREE.MeshBasicMaterial( { color: 0xff00ff } ) );
    mesh.position = new THREE.Vector3().addVectors( pointX, direction.multiplyScalar(0.5) );
    mesh.rotation = arrow.rotation.clone();
    return mesh;
}
function clear_text() {
    $("p").remove();
}
var sprite_controls = new function () {
    this.size = 50;
    this.sprite = 0;
    this.transparent = true;
    this.opacity = 0.6;
    this.colorize = 0xffffff;
    this.textcolor = "yellow";
    this.rotateSystem = true;

    this.clear = function (x,y) {
        sceneOrtho.children.forEach(function (child) {
            if (child instanceof THREE.Sprite) sceneOrtho.remove(child);
        })
    };

    this.draw_and_create = function (sprite,x,y,message) {
	var fontsize = 128;
	var ctx, texture,
	    spriteMaterial, 
	    canvas = document.createElement('canvas');
	ctx = canvas.getContext('2d');
	ctx.font = fontsize + "px Arial";

	// setting canvas width/height before ctx draw, else canvas is empty
	canvas.width = ctx.measureText(message).width;
	canvas.height = fontsize * 2; // fontsize * 1.5

	// after setting the canvas width/height we have to re-set font to apply!?! looks like ctx reset
	ctx.font = fontsize + "px Arial";        
	ctx.fillStyle = this.textcolor;        
	ctx.fillText(message, 0, fontsize);

	texture = new THREE.Texture(canvas);
	texture.minFilter = THREE.LinearFilter; // NearestFilter;
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial({
	    opacity: this.opacity,
	    color: this.colorize,
	    transparent: this.transparent,
	    map : texture});
	
	spriteMaterial.scaleByViewport = true;
	spriteMaterial.blending = THREE.AdditiveBlending;

        if (!sprite) {
	    sprite = new THREE.Sprite(spriteMaterial);
	}
	
	sprite.scale.set(this.size, this.size, this.size);
	sprite.position.set(x, y, 0);
	
	sceneOrtho.add(sprite);
	return sprite;
    };
};

// var color_scale = d3_scale.scaleRainbow().domain([MIN_EDGE_LENGTH, MAX_EDGE_LENGTH]);
// var color_scale = d3_scale.scalePlasma();

var color_scale = d3.scale.quantile().domain([MIN_EDGE_LENGTH, MAX_EDGE_LENGTH])
    .range(['violet', 'indigo', '#8A2BE2', 'blue', 'green', 'yellow', '#FFD700', 'orange', '#FF4500']);



function get_member_color(len) {
    if (len < MIN_EDGE_LENGTH)
	return d3.rgb("red");
    else if (len > MAX_EDGE_LENGTH)
	return d3.rgb("red");
    else {
	var p = (len - MIN_EDGE_LENGTH) / (MAX_EDGE_LENGTH - MIN_EDGE_LENGTH);
	return d3.rgb(color_scale(len));
    }
}

function updatePhysics(){
    world.step(mirroredWorld.dt);
    var mem_cnt = 0;

//    sprite_controls.clear();

    for(var i=0; i !== bodies.length; i++){
	var mesh = meshes[i];
	var body = bodies[i];
	if (bodies[i].structureKind == "member") {
	    mem_cnt++;
	    var a = body.link_a;
	    var b = body.link_z;
	    var ap = a.position;
	    var bp = b.position;
	    var ap3 = new THREE.Vector3(ap.x,ap.y,ap.z);
	    var bp3 = new THREE.Vector3(bp.x,bp.y,bp.z);
	    var mid = new THREE.Vector3().addVectors(ap3,bp3);
	    mid = mid.multiplyScalar(0.5);
	    mesh.up = new THREE.Vector3(0,0,1);//Z axis up
	    var vector = new THREE.Vector3().subVectors(ap3,bp3);
	    var axis = new THREE.Vector3(0, 1, 0);
	    mesh.position.copy(mid);

	    mesh.quaternion.setFromUnitVectors(axis, vector.clone().normalize());

	    var len = ap.distanceTo(bp);
	    var cd3 = get_member_color(len);


	    var geometry = mesh.geometry;
	    
	    for(var j = 0; j < geometry.faces.length; j++) {
		geometry.faces[j].color.setStyle( cd3 );
	    }

	    mesh.geometry.verticesNeedUpdate = true;
	    mesh.geometry.elementsNeedUpdate = true;        
	    mesh.geometry.colorsNeedUpdate = true;

	} else {
	    var p = body.position;
	    var p3 = new THREE.Vector3(p.x,p.y,p.z);
	    var p3 = p3.project(camera);
	    var x = (p3.x*renderer.getSize().width/2.0)+renderer.getSize().width/2;

	    var y = (p3.y*renderer.getSize().height/2.0)+renderer.getSize().height/2;
	    
	    body.sprite = sprite_controls.draw_and_create(body.sprite,x,y,""+body.name);

            mesh.position.copy(bodies[i].position);
	    mesh.quaternion.copy(bodies[i].quaternion);
	}
	
	mesh.geometry.verticesNeedUpdate = true;
	mesh.geometry.elementsNeedUpdate = true;        
	mesh.geometry.colorsNeedUpdate = true;    
    }
}
function render() {
    renderer.render(scene, camera);
    renderer.autoClear = false;
    // This is for the sprites....
    // WARNING! Calling this is someohow causing a massive memorey leak and poor performance!
    renderer.render(sceneOrtho, cameraOrtho);
}

function add_ground_plane(world,scene) {

    // Create a plane
    var groundShape = new CANNON.Plane();
    var floor_position = 0;

    var groundBody = new CANNON.Body({ mass: 0 });
    groundBody.addShape(groundShape);
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
    groundShape.position = new CANNON.Vec3(0,0,0);
    groundBody.name = "floor";
    world.add(groundBody);
    
    // floor

    var floorTexture = new THREE.ImageUtils.loadTexture( 'images/logo-white-background.png' );
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
    floorTexture.repeat.set( 10, 10 );
    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
    floorGeometry.position = new THREE.Vector3(0,0,0);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    mesh = floor;

    return [groundBody,mesh];
}

var spring = [];

Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};


function vectorToString(v) {
    return "["+v.x+","+v.y+","+v.z+"]";
}

/*
// This basically needs to take the bodies, read their positions,
// and update the geometry in the same way. Every Body has both
// an "id" and "index" field, but I don't know how to keep the
// association...
function update_three_js_from_bodies(scene,bodies)
{
    // at this point, the meshes and the bodies must match....
    for(var i = 0; i < bodies.length; i++) {
	var b = bodies[i];
	var m = meshes[i];

	// Not sure about this, but will try removing the mesh and
	// regenerating...
	scene.remove(m);
	var nm = generate_mesh_from_body(b);
	scene.add(b);
    }
}
*/

function generate_mesh_pairings_from_world(world,scene)
{
    var results = [];
    
    var vindex = 0;
    var mass = 1;
    var index_map = {};

    var vertex_index = 0;

    var body_cnt = 0;
    var mem_cnt = 0;
    // This is not yet physically modeling our system.
    var size = JOINT_RADIUS;
    function process_vertex(joint,v,results) {
	var cubeGeo = new THREE.SphereGeometry( size,32,32 );
	var cubeMaterial = new THREE.MeshPhongMaterial( { color: 0x0000ff } );
	var mesh = new THREE.Mesh(cubeGeo, cubeMaterial);
	mesh.castShadow = true;
	mesh.receiveShadow = true;
	results.unshift([joint,mesh]);
	body_cnt++;
    };

    //    var links_map = new Map();
    var links = [];

    for(var i = 0; i < robot_joints.length; i++) {
	var joint = robot_joints[i];
	process_vertex(joint,joint.position,results);
    }


    // This in fact needs to be a lot more complicated...but one step at a time.
    var w = MEDIAN_EDGE_LENGTH / 20;
    for(var lin in robot_members) {
	var link = robot_members[lin];
	var a = link.a;
	var b = link.b;
	var h = link.a.position.distanceTo(b.position);
	var cubeGeo = new THREE.BoxGeometry( w,h,w );
	var cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xff5533, specular: 0x111111, shininess: 200, vertexColors: THREE.FaceColors } );


	var mesh = new THREE.Mesh(cubeGeo, cubeMaterial);
	mesh.position.set(a.position.x,a.position.y+20,a.position.z);
	mesh.castShadow = true;
	mesh.receiveShadow = true;
	results.unshift([link.body,mesh]);
	mem_cnt++;
    }
    console.log("body_cnt "+body_cnt);
    console.log("mem_cnt "+mem_cnt);    
    return results;
}


function ccw_tetrahelix_vertex(n,edge_length) {
    // TODO: memoize these functions.
    var r = (3 * Math.sqrt(3) / 10) * edge_length;
    var h = (1/Math.sqrt(10)) *edge_length;
    var theta = Math.acos(-2/3);
    return new CANNON.Vec3( r * Math.cos(n*theta),  r * Math.sin(n*theta), n*h );
}

function add_member_spring(a,b,world) {
    var stiffness = 10;
    var damping = 0.3;
    restlength = a.position.distanceTo(b.position);
    
    var c = new CANNON.DistanceConstraint(a,b,restlength);
    world.addConstraint(c);
    
}

// To do a great job with this, we really need to know the
// range of possible values, but I'll fake it..
function alphabetic_name(n) {
    if (n < 26) {
	return String.fromCharCode(65+n);
    } else {
	if (n < 26*26) {
	    return alphabetic_name(Math.floor(n/26))+alphabetic_name(n % 26);
	} else {
	    return ""+n;
	}
    }
}


function load_NTetGlussBot(world,tets,pvec) {

    // Okay, so here we need to create the geometry of the tetrahelix.
    // This could be done in a variety of ways.
    // Probably the most mathematical is to first define a vector
    // representing the center axis, and then use a formula the nth vertex.
    // Looks like some math as been worked out by R. W. Gray:
    // http://www.rwgrayprojects.com/rbfnotes/helix/helix01.html
    // I guess I will use a CounterClockWise (ccw) tetrahelix:
    // Vn = (r cos(n*theta), r sin(n*theta), n*h)

    var n = tets+3;
    var member_radius = MEDIAN_EDGE_LENGTH/ 20;
    var mass = 1.0;
    for(var i = 0; i < n; i++) {
	var v = ccw_tetrahelix_vertex(i,MEDIAN_EDGE_LENGTH);
	v = v.vadd(pvec);
	var boxBody = new CANNON.Body({ mass: mass });
	var    boxShape = new CANNON.Sphere(JOINT_RADIUS);
	boxBody.addShape(boxShape);
	boxBody.position.set(v.x,v.y,v.z);
	boxBody.mass = 1;
	boxBody.angularDamping = 0.9;
	boxBody.linearDamping = 0.9;
	boxBody.name = alphabetic_name(i);
	robot_joints.push(boxBody);
	world.add(boxBody);

	for(var k = 0; k < Math.min(3,i) && k < i; k++) {
	    var h = i-(k+1);
	    console.log(i+" to "+h);
	    add_member_spring(robot_joints[h],robot_joints[i],world);

	    // Okay, here I also want to add a new body to represent the actuator
	    // This may require some roation math, but for now let me just put it
	    // in the cetner
	    var memBody = new CANNON.Body({ mass: mass });
	    var b_z = robot_joints[i];
	    var b_a = robot_joints[h];
	    var v_z = b_z.position;
	    var v_avg = v_z.vadd(b_a.position);
	    v_avg.scale(0.5);
	    memBody.position = v_avg;
	    memBody.mass = 1;
	    memBody.angularDamping = 0.9;
	    memBody.linearDamping = 0.9;
	    var link = { a: b_a, b: b_z, body: memBody};
	    robot_members.push(link);
	    memBody.structureKind = "member";
	    memBody.link_a = b_a;
	    memBody.link_z = b_z;
	    world.add(memBody);
	}
    }
}

function add_robot(world,scene) {
    var pvec = new CANNON.Vec3(0,INITIAL_HEIGHT,0);
    load_NTetGlussBot(world,NUMBER_OF_TETRAHEDRA,pvec);
    var pairings = generate_mesh_pairings_from_world(world,scene);
    for(var i = 0; i < pairings.length; i++) {
	scene.add(pairings[i][1]);
    }
    
    // The timing here is making this asynchronous, which is not ideal...
    pairings.forEach(function (item) {
	push_body_mesh_pair(item[0],item[1]);
    });
}

function initCannon(){
    // Setup our world
    world = new CANNON.World();
    world.quatNormalizeSkip = 0;
    world.quatNormalizeFast = false;

    world.gravity.set(0,-5,0);
    world.broadphase = new CANNON.NaiveBroadphase();

    var item = add_ground_plane(world,scene)
    scene.add(item[1]);
    push_body_mesh_pair(item[0],item[1]);
    
    // This would be better as a function that
    // returns a robot, but I am dependent on some sort of
    // geometry for the construction of the robot..
    add_robot(world,scene);

    // Joint body
    var shape = new CANNON.Sphere(JOINT_RADIUS);
    jointBody = new CANNON.Body({ mass: 0 });
    jointBody.addShape(shape);
    jointBody.collisionFilterGroup = 0;
    jointBody.collisionFilterMask = 0;
    world.add(jointBody)
}

function addMouseConstraint(x,y,z,body) {
    // The cannon body constrained by the mouse joint
    constrainedBody = body;

    // Vector to the clicked point, relative to the body
    var v1 = new CANNON.Vec3(x,y,z).vsub(constrainedBody.position);

    // Apply anti-quaternion to vector to tranform it into the local body coordinate system
    var antiRot = constrainedBody.quaternion.inverse();
    pivot = antiRot.vmult(v1); // pivot is not in local body coordinates

    // Move the cannon click marker particle to the click position
    jointBody.position.set(x,y,z);

    // Now we want to disable all attached length constraints (and actually add others)
    for(var i = 0; i < world.constraints.length; i++) {
	var c = world.constraints[i];
	if ((c.bodyA == body) || (c.bodyB == body)) {
	    c.disable();
	}
    }

    // Create a new constraint
    // The pivot for the jointBody is zero
    mouseConstraint = new CANNON.PointToPointConstraint(constrainedBody, pivot, jointBody, new CANNON.Vec3(0,0,0));
    mouseConstraint.attachedBody = body;

    // Add the constriant to world
    world.addConstraint(mouseConstraint);
}


var cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xff5533, specular: 0x111111, shininess: 200, vertexColors: THREE.FaceColors } );


// This functions moves the transparent joint body to a new postion in space

var moveCnt = 0;
function moveJointToPoint(x,y,z) {
    // Move the joint body to a new position
    jointBody.position.set(x,y,z);


    var body = mouseConstraint.attachedBody;
    
    var w = MEDIAN_EDGE_LENGTH / 20;
    moveCnt++;
    //    if ((moveCnt % 10) == 0) {
    //	console.log(moveCnt);
    for(var i = 0; i < bodies.length; i++) {
	var bx = bodies[i];
	var mx = meshes[i];
	if (bx.structureKind == "member") {
	    var a = bx.link_a;
	    var b = bx.link_z;

	    if ((a == body) || ( b == body)) {
		// HERE is where we must deal with the mesh changing sizes, not in update physics.
		var ap = a.position;
		var bp = b.position;
		var len = ap.distanceTo(bp);
		
		var cd3 = d3.rgb(color_scale(len));
		
		// TODO: This needs to be computed from the real min and max, which I haven't set up yet.
		var d = len;
		
		var h = a.position.distanceTo(b.position);
		var cubeGeo = new THREE.BoxGeometry( w,h,w );

		var mesh = new THREE.Mesh(cubeGeo, cubeMaterial);

		scene.remove(meshes[i]);
		scene.add(mesh);
		meshes[i] = mesh;
		for(var j = 0; j < mesh.geometry.faces.length; j++) {
    		    mesh.geometry.faces[j].color.setStyle( color_scale(d) );
		}
		
		mesh.position.set(a.position.x,a.position.y,a.position.z);
		mesh.castShadow = true;
		mesh.receiveShadow = true;
		
		mesh.geometry.verticesNeedUpdate = true;
		mesh.geometry.elementsNeedUpdate = true;        
		mesh.geometry.colorsNeedUpdate = true;

	    }
	}
	//	}	
	
    }


    // Could we here change the member lengths appropriately?
    mouseConstraint.update();
}

function render_constraints() {
    for(var i = 0; i < world.constraints.length; i++) {
	var c = world.constraints[i];
	console.log("("+c.bodyA.name+","+c.bodyB.name+") = "+c.distance);	    	
    }
}

function removeJointConstraint() {
    // Remove constriant from world
    if (!mouseConstraint) {
	return;
    }
    world.removeConstraint(mouseConstraint);
    // Now we want to disable all attached length constraints (and actually add others)

    var body = mouseConstraint.attachedBody;
    if (body) {
	
	for(var i = 0; i < world.constraints.length; i++) {
	    var c = world.constraints[i];
	    if ((c.bodyA == body) || (c.bodyB == body)) {
		var newrestlength = c.bodyA.position.distanceTo(c.bodyB.position);
		c.distance = newrestlength;
		c.update();
		c.enable();	    
	    } else {
	    	c.enable();
	    }
	}
    }
    render_constraints();
    mouseConstraint = false;
    moveCnt = 0;
}

function execute_code(id) {
    var command = $("#cli").val();
    var result = eval(command);
    console.log(command);
    console.log(result);    
}

function render_physical_model(id) {
    var pmodel = extract_physical_node_model();
    var command = $("#pmodel").val(JSON.stringify(pmodel,null,2));
}

function render_actuator_model(id) {
    var pmodel = extract_physical_node_model();
    
    var am = model_to_actuator_space(pmodel);
    
    var command = $("#amodel").val(JSON.stringify(am,null,2));
}


function extract_physical_node_model() {
    var nodes = [];
    for(var i = 0; i < bodies.length; i++) {
	var bx = bodies[i];
	if ((bx.structureKind != "member") && (bx.name != "floor")) {
	    nodes.push({ name: bx.name,
			 position: new CANNON.Vec3(bx.position.x,bx.position.y,bx.position.z) });
	}
    }
    return nodes;
}

// Here I am developing some "poses" for fun.
// This may allow us to simulate a gait.
// This will require us to cross-reference the emacs-ctl.el file and
// begin integration with that.
// A pose exists in Actuator space rather than in cartesian space.
var lo = 0;
var mid = 450;
var hi = 900;

var flat_pose = { A0: 0, A1: 100+mid, A2: 100+mid, A3: 300+lo, A4: mid, A5: mid,
		  B0: 0, B1: 100+mid, B2: 100+mid, B3: 300+lo, B4: mid, B5: mid};

var actuator_to_length = d3.scale.linear().domain([0,1023]).range([MIN_EDGE_LENGTH,MAX_EDGE_LENGTH]);

function flat() {
    assume_pose(flat_pose);
}

function invert_actuator_map(am) {
    var inversion = {};

    for (var key in am) {
	if (am.hasOwnProperty(key)) {
	// key: the name of the object key
	    // index: the ordinal position of the key within the object
	    for(var k in am[key]) {
		inversion[am[key][k]] = [key,k];
	    }
	}
    };
    return inversion;
}

function model_to_actuator_space(bodies) {
    
//    var pose = { A0: 0, A1: 100+mid, A2: 100+mid, A3: 300+lo, A4: mid, A5: mid,
    //		 B0: 0, B1: 100+mid, B2: 100+mid, B3: 300+lo, B4: mid, B5: mid};
    var pose = {};

    for(var lin in robot_members) {
	var mem = robot_members[lin];  
	var a = mem.a;
	var b = mem.b;
	var d = actuator_to_length.invert(a.position.distanceTo(b.position)).toFixed(0);
	for (var key in inversion_actuator_map) {
	    if (inversion_actuator_map.hasOwnProperty(key)) {
		var link = inversion_actuator_map[key];
		if ((link[0] == a.name) && (link[1] == b.name) ||
		    (link[1] == a.name) && (link[0] == b.name)) {
		    pose[key] = d;
		}
	    }
	}
    }

    return pose;
}

function half_size() {
    factor_size(0.5);
}

function double_size() {
    factor_size(2.0);
}

function factor_size(f) {
    
    for(var i = 0; i < world.constraints.length; i++) {
	var c = world.constraints[i];
	world.removeConstraint();
    }
    
    for(var lin in robot_members) {
	var link = robot_members[lin];  
	var a = link.a;
	var b = link.b;
	var d = a.position.distanceTo(b.position);
	var c = new CANNON.DistanceConstraint(a,b,d*f);
	world.addConstraint(c);
    }
}

function assume_pose(pose) {
    for(var i = 0; i < world.constraints.length; i++) {
	var c = world.constraints[i];
	world.removeConstraint();
    }
    
    for(var lin in robot_members) {
	var link = robot_members[lin];
	var a = link.a;
	var b = link.b;
	var act = actuator(a.name,b.name);
	var d = actuator_to_length(pose[act]);
	var c = new CANNON.DistanceConstraint(a,b,d);
	world.addConstraint(c);
    }
    var STEPS_TO_TAKE = 3;
    for(var j = 0; j < STEPS_TO_TAKE; j++) {
	updatePhysics();
    }
}


// To support bigger robots, I will have to allow numbering of these things.
var actuator_map = { "A": { "B": "A3", "C": "A5", "D": "A4" },
		     "B": { "C": "A0", "D": "A2", "E": "A1" },
		     "C": { "D": "B0", "E": "B2", "F": "B5"},
		     "D": { "E": "B1", "F": "B4" },
		     "E": {  "F":  "B3"}
		   };

var inversion_actuator_map = invert_actuator_map(actuator_map);
        

// Compute the actuator name between the two 
function actuator(b1,b2) {
    return (b1 < b2) ?
	actuator_map[b1][b2] : actuator_map[b2][b1];
}

// Compute the actuator name between the two 
function regenerate() {
    for(var i = 0; i < bodies.length; i++) {
	var bx = bodies[i];
	var mx = meshes[i];
	if (bx.structureKind == "member") {
	    scene.remove(meshes[i]);	    
	}
    }

    var pairings = generate_mesh_pairings_from_world(world,scene);
    for(var i = 0; i < pairings.length; i++) {
	scene.add(pairings[i][1]);
    }

    // The timing here is making this asynchronous, which is not ideal...
    pairings.forEach(function (item) {
	push_body_mesh_pair(item[0],item[1]);
    });

    var STEPS_TO_TAKE = 3;
    for(var j = 0; j < STEPS_TO_TAKE; j++) {
	updatePhysics();
    }
}

// Initialize Three.js
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

var scene = init_scene();
initCannon(scene);
finish_scene_preparation(scene);
animate();
        </script>
    </body>
</html>
