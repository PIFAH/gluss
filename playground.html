<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>gluss playground</title>
        <style>
            html, body {
                width: 100%;
                height: 100%;
                margin:0;
                padding:0;
                overflow: auto;
            }
	    .robscroll {
	    overflow: auto;
	    background: #fff;
	    }
        </style>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  </head>
    <body>
    <div id="world"></div>
    <div id="worldspace"></div>
    <div id="control" class="robscroll">
	<div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Control Graphical Interactions</h3>
	    <span class="pull-left clickable"><i class="glyphicon glyphicon-chevron-up"></i></span>
	  </div>
    <div class="panel-body">
    
	    <button id="gravity_ctl" type="button" onclick="toggle_gravity()" >
	      Turn Gravity Off    
	    </button>
	    <button id="auto_rectify_ctl" type="button" onclick="auto_rectify_toggle()" >
	      Turn Auto Rectify On
	    </button>
	    <button type="button" onclick="rectify()">
	      Rectify
	    </button>
	    <button type="button" onclick="disable_con()">
	      Disable Constraints On Manipulation
	    </button>
	    <button type="button" onclick="allow_con()">
	      Allow Constraints On Manipulation
	    </button>
	    <button type="button" onclick="step_con()">
	      Use STEP MODE
	    </button>
	    <button type="button" onclick="reset_to_default()">
	      Reset to Default
	    </button>
    </div>
    </div>
	<div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Standard Poses</h3>
	    <span class="pull-left clickable"><i class="glyphicon glyphicon-chevron-up"></i></span>
	  </div>
	  <div class="panel-body">
	    <button type="button" onclick="big_size()">
	      Big size
	    </button>
	    <button type="button" onclick="small_size()">
	      Small size
	    </button>
	    <!-- These are currently not workin....
		 <button type="button" onclick="flat()">
		   Flat Pose
		 </button>
		 <button type="button" onclick="regenerate()">
		   Regenerate
		 </button>
		 -->
	  </div>
	</div>

	<!--
	    <textarea id="cli" rows="8" cols="80">
	      Imagine enterring a command here.
	    </textarea>
	    <button type="button" onclick="execute_code(this)">
	      Execute    
	    </button>
	    -->

	<div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Pose and Gait</h3>
	    <span class="pull-left clickable"><i class="glyphicon glyphicon-chevron-up"></i></span>
	  </div>
	  <div class="panel-body">
	    <button type="button" onclick="load_pose()">
	      Load Pose from JSON
	    </button>
	    
	    <span>
	      <button type="button" onclick="name_pose()">
		Name Pose
	      </button>
	      Pose Name:
	      <input id="posename" type="text" name="pose"><br>
    </span>
    Standard poses: <div id="stdposes"></div>
    Standard gaits: <div id="stdgaits"></div>    
	    My named poses: <div id="poslist"></div>
	    <span>
	      <button type="button" onclick="execute_gait()">
		Execute Gait
	      </button>
	      Gait:
	      <textarea id="gait" rows="8" cols="80"></textarea>
	    </span>
	  </div>
	</div>
	<div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Robot Control</h3>
	    <span class="pull-left clickable"><i class="glyphicon glyphicon-chevron-up"></i></span>
	  </div>
	  <div class="panel-body">
            <button type="button" onclick="do_test()">
	      Send Pose to Robot
	    </button>
	    Send Poses To URL:
	    <input id="poseurl" type="text" name="poseurl"><br>
	    <div id="robotcomresult">
	    </div>
	  </div>
	</div>	
	
	<div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">JSON Interactions</h3>
	    <span class="pull-left clickable"><i class="glyphicon glyphicon-chevron-up"></i></span>
	  </div>
	  <div class="panel-body">

<div>
	    <textarea id="pmodel" rows="8" cols="80">
	      The physcial model positions as JSON object will be rendered here.
	    </textarea>
            
            <textarea id="amodel" rows="8" cols="80">
	      The actuator positions as JSON object will be rendered here.
    </textarea>
    </div>
	  <div>  
	    <button type="button" onclick="render_physical_model(this)">
	      Render Physical    
	    </button>
	    <button type="button" onclick="render_actuator_model()">
	      Render Actuators
	    </button>
	    <button type="button" onclick="render_actuator_model('escaped')">
	      Render Actuators Esacped
	    </button>
</div>
	  </div>
	</div>
      </div>
    </body>

    <script src="./js/three.js"></script>
        <script src="./js/Detector.js"></script>
    <script src="./js/cannon.js"></script>
    	<script src="./js/Projector.js"></script>	
    <script src="./js/STLLoader.js"></script>
    <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>    
   <script src="./js/d3-scale.min.js"></script>
   <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>

<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="https://d3js.org/d3-collection.v1.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-format.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-time.v1.min.js"></script>
<script src="https://d3js.org/d3-time-format.v2.min.js"></script>
<script src="https://d3js.org/d3-scale.v1.min.js"></script>

    
    <script src="./js/OrbitControls.js"></script>
     <script type="text/javascript" src="./js/dat.gui.js"></script> 
    <script>






function convert_to_number(obj) {
    for(var k in obj) {
	if (typeof obj[k] == "string") {
	    obj[k] = parseInt(obj[k]);
	}
    }
    return obj;
}


var url_for_robot = "http://127.0.0.1:9000";
$("#poseurl").val(url_for_robot);

// A "robot" is really a graph of vertices with connections.
// In physical realization, the connections are actuators with length limits.
// In our first implementation, we will treat this as a set of springs in
// the cannon.js world...
// So in a sense we have 3 virtual worlds here: the abstract world
// of the robot, the cannon.js world of almost-physical objects, and
// the three.js world of meshes.
// This will be made slightly more confusing by utilizing Three.js
// and cannon.js utility classes (such as Vector) for convenience,
// even in the abstract world of the robot space.

// TODO: I hate global variables ---- I'd like to encapsulate this
// into a class.


// The MirroredWorld comtains both the Cannon world of physics
// and the Three.js world of renderable shapes and meshes.
var MW = function() {
    this.dt = 1/60;
    this.GROUND_PLANE_MESH;
    this.GROUND_BODY;
    this.meshes = [];
    this.bodies = [];
    this.cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xff5533, specular: 0x111111, shininess: 200, vertexColors: THREE.FaceColors } );



    // Okay, so we have a few problems here.  All parts of the robot should
    // interact with floor and the obstacles, but until we implement a prismatic joint,
    // we don't want the robots parts interacting with themselves.
    // So I will attempt to put the ground and obstacles in Group 1.
    // The go in Group2.  The robots filter group is "GROUP1".
    // The robots filter group is GROUP1 & GROUP2.

    // Collision filter groups - must be powers of 2!
    this.GROUP1 = 1;
    this.GROUP2 = 2;

    this.groundMaterial = new CANNON.Material("groundMaterial");
    
    this.global_friction = 1.0;
    
    // Adjust constraint equation parameters for ground/ground contact
    this.ground_ground_cm = new CANNON.ContactMaterial(this.groundMaterial, this.groundMaterial, {
	friction: this.global_friction,
	restitution: 0.2,
	contactEquationStiffness: 1e8,
	contactEquationRelaxation: 3,
	frictionEquationStiffness: 1e8,
	frictionEquationRegularizationTime: 3,
    });

    this.BASIC_BODY_MASS = 1; // This is kilograms.

    this.cworld;

    this.world_live = true;
    this.world_dead = false;

    this.CONSTRAINT_FORCE_SMALL = 1.0;
    this.CONSTRAINT_FORCE_LARGE = 10000.0;

    this.MEMBER_FRACTION = 20;

    // These things should actually be a part of the ROBOT, not the mirrored world!
    // These are in meters, measured joint-center to joint-center
    this.MAX_EDGE_LENGTH = 0.470;
    this.MIN_EDGE_LENGTH = 0.330;
    this.MEDIAN_EDGE_LENGTH = (this.MAX_EDGE_LENGTH + this.MIN_EDGE_LENGTH)/2;
    this.JOINT_RADIUS = 0.0508 / 2; // This is the 2" ball.


// This is sometimes useful for debugging.    
//    this.jointGeo = new THREE.BoxGeometry( this.JOINT_RADIUS*2,this.JOINT_RADIUS*2,this.JOINT_RADIUS*2);
    this.jointGeo = new THREE.SphereGeometry( this.JOINT_RADIUS,32,32);
    this.jointMaterial = new THREE.MeshPhongMaterial( { color: 0x0000ff } );

    this.playgroundDimensions = {
	w:10,
	d:10,
	h:3
    };

    this.INITIAL_HEIGHT = 0.3;
    this.Y_GRAVITY_FORCE = -10;

    
    this.robot = {
	robot_joints: [],
	robot_members: []
    };

    this.obstacles = [];
    this.obstacleSize = this.MEDIAN_EDGE_LENGTH*4;

    this.vector_up = new THREE.Vector3(0,0,1);
    this.vector_axis = new THREE.Vector3(0, 1, 0);

    this.floorTexture = new THREE.ImageUtils.loadTexture("images/logo-white-background.png");    
    this.ROBOT_PAIRINGS = null;

    this.most_recent_constraints;    
};

var mw = new MW();



var GUI = function() {
    this.controls = null;
    this.SCREEN_WIDTH = window.innerWidth;
    this.SCREEN_HEIGHT = 1*window.innerHeight/2.0;
    this.TIME_BETWEEN_POSES_MS = 3000;
    this.GAIT_SUBDIVISIONS = 10;
    this.cameraOrtho = null;
    this.sceneOrtho = null;
    this.renderer = null;
    this.gplane=false;
    this.clickMarker=false;
    this.container = null;
    this.camera = null;
    this.scene = null;

    this.NUMBER_OF_TETRAHEDRA = 5;
    //    this.NUMBER_OF_TETRAHEDRA = 1;

    this.jointBody = null;
    this.mouseConstraint = null;
    this.projector = null;
    this.grid_scene = null;

    this.FORCE_REGIME = "DISABLE";

    this.gravity_on = true;
    this.world_container = $("#world");
    this.standard_objs;
    this.standard_ctx;
};


var gui = new GUI();


$.getJSON( "./standard_gaits.json")
    .done(function( json ) {
	gui.standard_objs = json;
	gui.standard_ctx = generate_context_from_standard(gui.standard_objs);

	var local_objs = [];
	for (var i = 0; i < localStorage.length; i++){
	    var obj = localStorage[localStorage.key(i)];
	    var pobj = JSON.parse(obj);
	    pobj["pose"] = convert_to_number(pobj["pose"])
	    gui.standard_ctx[localStorage.key(i)] = pobj;
	}
	update_standard_poses();	
    })
  .fail(function( jqxhr, textStatus, error ) {
    var err = textStatus + ", " + error;
    console.log( "Request Failed: " + err );
  });


// var getTexture = function () {
//     var texture = new THREE.TextureLoader("./logo-tight.png");
//     return texture;
// }

function push_body_mesh_pair(body,mesh) {
    mw.meshes.push(mesh);
    mw.bodies.push(body);
}
function clear_non_floor_body_mesh_pairs() {
    mw.meshes = [];
    mw.bodies = [];
    mw.meshes.push(mw.GROUND_PLANE_MESH);
    mw.bodies.push(mw.GROUND_BODY);
    
}

function establish_controls(camera,container) {
    gui.controls = new THREE.OrbitControls( camera, container );
    //controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
    gui.controls.enableDamping = true;
    gui.controls.dampingFactor = 0.25;
    gui.controls.enableZoom = true;
    gui.controls.enabled = true;

}
function init_scene() {
    gui.projector = new THREE.Projector();

    while (gui.world_container.get()[0].hasChildNodes()) {   
	gui.world_container.get()[0].removeChild(gui.world_container.get()[0].firstChild);
    }
    
    gui.container = document.createElement( 'div' );
    gui.world_container.append( gui.container );	

    gui.container.style["max-height"] = 800;

    gui.container.style.backgroundColor = "blue";

    // scene
    gui.scene = new THREE.Scene();
    gui.scene.fog = new THREE.Fog( 0x000000, 500, 10000 );

    gui.sceneOrtho = new THREE.Scene();


    gui.grid_scene = new THREE.Scene();
    gui.grid_scene.fog = new THREE.Fog( 0x000000, 500, 10000 );    

    //
    gui.renderer = new THREE.WebGLRenderer( { antialias: true } );
    gui.renderer.setClearColor( gui.scene.fog.color );
    // After we do this, we want to start using renderer.getSize.
    gui.renderer.setSize( window.innerWidth,  window.innerHeight*(1/2)  );    

    // camera
    gui.camera = new THREE.PerspectiveCamera( 35, gui.renderer.getSize().width / (gui.renderer.getSize().height), 0.5, 10000 );
    gui.camera.position.set(3, 0.25, 0);
    var origin = new THREE.Vector3(0,0,0);
    gui.camera.lookAt(origin);
    gui.camera.quaternion.setFromAxisAngle(new THREE.Vector3(0,1,0), (Math.PI/2));

    gui.cameraOrtho = new THREE.OrthographicCamera( 0, gui.SCREEN_WIDTH, gui.SCREEN_HEIGHT, 0, - 10, 10 );

    establish_controls(gui.camera,gui.container);
    
    gui.scene.add(gui.camera);

    // lights
    var light, materials;
    gui.scene.add( new THREE.AmbientLight( 0x666666 ) );

    gui.scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

    gui.grid_scene.add( new THREE.AmbientLight( 0x666666 ) );
    
    addShadowedLight( 1, 1, 1, 0xffffff, 1.35 );
    addShadowedLight( 0.5, 1, -1, 0xffaa00, 1 );
    
    light = new THREE.DirectionalLight( 0xffffff, 1.75 );
    var d = 200;

    light.position.set( d, d, d );

    light.castShadow = true;
    light.shadow.CameraVisible = true;

    light.shadow.MapWidth = 1024;
    light.shadow.MapHeight = 1024;

    light.shadow.CameraLeft = -d;
    light.shadow.CameraRight = d;
    light.shadow.CameraTop = d;
    light.shadow.CameraBottom = -d;

    light.shadow.CameraFar = 3*d;
    light.shadow.CameraNear = d;
    light.shadow.Darkness = 0.5;

    light = new THREE.DirectionalLight( 0xffffff, 1.75 );
    var d = 20;

    light.position.set( -d, d, -d );

    light.castShadow = true;
    //light.shadow.CameraVisible = true;

    light.shadow.MapWidth = 1024;
    light.shadow.MapHeight = 1024;

    light.shadow.CameraLeft = -d;
    light.shadow.CameraRight = d;
    light.shadow.CameraTop = d;
    light.shadow.CameraBottom = -d;

    light.shadow.CameraFar = 3*d;
    light.shadow.CameraNear = d;
    light.shadow.Darkness = 0.5;

    gui.scene.add( light );

    gui.grid_scene.add(light);
    gridInit(gui.grid_scene,mw.playgroundDimensions);

    return gui.scene;
}

function addShadowedLight( x, y, z, color, intensity ) {
    var directionalLight = new THREE.DirectionalLight( color, intensity );
    directionalLight.position.set( x, y, z );
    gui.scene.add( directionalLight );
    directionalLight.castShadow = true;
    var d = 1;
    directionalLight.shadow.camera.left = -d;
    directionalLight.shadow.camera.right = d;
    directionalLight.shadow.camera.top = d;
    directionalLight.shadow.camera.bottom = -d;
    directionalLight.shadow.camera.near = 1;
    directionalLight.shadow.camera.far = 4;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.bias = -0.005;
}


// This needs to be changed to init the floor and ground together...
function finish_scene_preparation(schen) {
    material = new THREE.MeshLambertMaterial( { color: 0x777777 } );
    markerMaterial = new THREE.MeshLambertMaterial( { color: 0xff0000 } );

    while (gui.container.hasChildNodes()) {   
	gui.container.removeChild(gui.container.firstChild);
    }
    
    gui.container.appendChild( gui.renderer.domElement );

    
    gui.renderer.gammaInput = true;
    gui.renderer.gammaOutput = true;
    gui.renderer.shadowMap.Enabled = true;

    window.addEventListener( 'resize', onWindowResize, false );

    window.addEventListener("mousemove", onMouseMove, false );
    window.addEventListener("mousedown", onMouseDown, false );
    window.addEventListener("mouseup", onMouseUp, false );
}

function setClickMarker(x,y,z) {
    if(!gui.clickMarker){
        var shape = new THREE.SphereGeometry(mw.JOINT_RADIUS/4, 8, 8);
        gui.clickMarker = new THREE.Mesh(shape, markerMaterial);
        gui.scene.add(gui.clickMarker);
    }
    gui.clickMarker.visible = true;
    gui.clickMarker.position.set(x,y,z);
}

function removeClickMarker(){
    gui.clickMarker.visible = false;
}

function onMouseMove(e){
    // Move and project on the plane
    if (gui.gplane && gui.mouseConstraint) {

	var mouse3D = new THREE.Vector3( ( event.clientX / gui.renderer.getSize().width ) * 2 - 1,   //x
					 -( event.clientY / (gui.renderer.getSize().height) ) * 2 + 1,  //y
					 0.5 );                                            //z
	
	mouse3D.unproject( gui.camera );

        var pos = projectOntoPlane(e.clientX,e.clientY,gui.gplane,gui.camera);
        if(pos){
            setClickMarker(pos.x,pos.y,pos.z,gui.scene);
            moveJointToPoint(pos.x,pos.y,pos.z);
        }
    }
}

function onMouseDown(e){
    // Find mesh from a ray

    var mouse3D = new THREE.Vector3( ( e.clientX / gui.renderer.getSize().width ) * 2 - 1,   //x
				     -( e.clientY / (gui.renderer.getSize().height) ) * 2 + 1,  //y
				     0.5 );                                            //z
    mouse3D.unproject( gui.camera );
    mouse3D.sub(gui.camera.position);
    mouse3D.project( gui.camera );
    
    var entity = findNearestIntersectingObject(e.clientX,e.clientY,gui.camera,mw.meshes);
    var pos = entity.point;
    // This is fragile, we need to be able to change this geometry....
    
    if (pos && (entity.object.geometry instanceof THREE.SphereGeometry
		 ||
		(entity.object.name.startsWith("obstacle"))
		||
		(entity.object.name.startsWith("member"))
		)
       ){
        var idx = mw.meshes.indexOf(entity.object);

	if (e.shiftKey) {
	    // If the shiftKey is down, we are going to toggle whether or not this one is fixed...
	    // and we will visually represent that by turning the joint red, I guess.
	    console.log(mw.bodies[idx]);
	    var b = mw.bodies[idx];
	    b.fixed_in_world = !b.fixed_in_world;
	    if (b.fixed_in_world) {
		b.mass = 0;
		entity.object.material.color.setHex( 0xff0000 );		
	    } else {
		b.mass = mw.BASIC_BODY_MASS;
		entity.object.material.color.setHex( 0x0000ff );				
	    }
		b.updateMassProperties();	    
	} else {
//            constraintDown = true;
            // Set marker on contact point
            setClickMarker(pos.x,pos.y,pos.z,gui.scene);

            // Set the movement plane
            setScreenPerpCenter(pos,gui.camera);


            if(idx !== -1){
		addMouseConstraint(pos.x,pos.y,pos.z,mw.bodies[idx]);
            }
	}
    }
}

// This function creates a virtual movement plane for the mouseJoint to move in
function setScreenPerpCenter(point, camera) {
    // If it does not exist, create a new one
    if(!gui.gplane) {
	// We need to be precese about what these coordinates are!
        var planeGeo = new THREE.PlaneGeometry(4000,4000);
	// Something has change in three.js, apparently ray casting only
	// works with visible objects.  Since we are creating a plan to
	// move the joint in, I am going to try to create an object here that makes since.
	var plane_material = new THREE.MeshLambertMaterial( { color: 0x110000 } );
	plane_material.transparent = true;
	plane_material.opacity = 0.0;
	
        var plane = gui.gplane = new THREE.Mesh(planeGeo,plane_material);
	//        plane.visible = false; // Hide it..
	// ????
	
        gui.scene.add(gui.gplane);
    }
    gui.gplane.visible = true;
    gui.gplane.name = "movementplane";
    gui.controls.enabled = false;

    // Center at mouse position
    gui.gplane.position.copy(point);

    // Make it face toward the camera
    gui.gplane.quaternion.copy(camera.quaternion);
}

function onMouseUp(e) {
	var mouse3D = new THREE.Vector3( ( event.clientX / gui.renderer.getSize().width ) * 2 - 1,   //x
					 -( event.clientY / (gui.renderer.getSize().height) ) * 2 + 1,  //y
					 0.5 );                                            //z
	
	mouse3D.unproject( gui.camera );

        var pos = projectOntoPlane(e.clientX,e.clientY,gui.gplane,gui.camera);
        if(pos){
            setClickMarker(pos.x,pos.y,pos.z,gui.scene);
            moveJointToPoint(pos.x,pos.y,pos.z);
        }
    
//    constraintDown = false;
    // remove the marker
    removeClickMarker();

    // Send the remove mouse joint to server
    removeJointConstraint();

        // This is an experimental positioning
    do_test();


    if (gui.gplane.visible == true) {
	gui.gplane.visible = false;
	// We need to re-establish the controls because I don't have
	// any good way of exiting the active state...
	gui.controls.dispose();
	establish_controls(gui.camera,gui.container);
    }

}

var lastx,lasty,last;
function projectOntoPlane(screenX,screenY,thePlane,camera) {
    var x = screenX;
    var y = screenY;
    var now = new Date().getTime();
    // project mouse to that plane
    // This is probably highly wrong...
    // this means that we can only fold an object on itself.
    // I think this would work if you have
    var hit = findNearestIntersectingObject(screenX,screenY,camera,[thePlane]);
    lastx = x;
    lasty = y;
    last = now;
    if(hit)
        return hit.point;
    else return false;
}
function findNearestIntersectingObject(clientX,clientY,camera,objects) {
    var mouse3D = new THREE.Vector3( ( event.clientX / gui.renderer.getSize().width ) * 2 - 1,   //x
                                     -( event.clientY / (gui.renderer.getSize().height) ) * 2 + 1,  //y
                                     0.5 );                                            //z
    
    var mouse = new THREE.Vector2();
    mouse.x = (event.clientX / gui.renderer.getSize().width) * 2 - 1;
    mouse.y = -(event.clientY / (gui.renderer.getSize().height)) * 2 + 1; 

    var raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects( objects );        
    // Change color if hit block
    // if ( intersects.length > 0 ) {
    // 	if (intersects[0].object.name != "movementplane") 
    // 	    intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
    // }
    var closest = false;
    if (intersects.length > 0) {
        closest = intersects[0];
    }

    return closest;
}

// Function that returns a raycaster to use to find intersecting objects
// in a scene given screen pos and a camera, and a projector
function getRayCasterFromScreenCoord (screenX, screenY, camera, projector) {
    var mouse3D = new THREE.Vector3();
    // Get 3D point form the client x y
    mouse3D.x = (screenX / gui.renderer.getSize().width) * 2 - 1;
    mouse3D.y = -(screenY / gui.renderer.getSize().height) * 2 + 1;
    mouse3D.z = 0.5;
    return projector.pickingRay(mouse3D, camera);
}

function onWindowResize() {
    gui.renderer.setSize( window.innerWidth, (1*window.innerHeight)/2 );
    
    gui.camera.updateProjectionMatrix();

    gui.SCREEN_WIDTH = gui.renderer.getSize().width;
    gui.SCREEN_HEIGHT = gui.renderer.getSize().height;
    gui.camera.radius = ( gui.SCREEN_WIDTH + gui.SCREEN_HEIGHT ) / 4;

    gui.cameraOrtho = new THREE.OrthographicCamera( 0, gui.SCREEN_WIDTH, gui.SCREEN_HEIGHT, 0, - 10, 10 );
}
function animate() {
    if (mw.world_live) {
	requestAnimationFrame( animate );
	mw.world_dead = false;
    } else {
	mw.// TODO: All of this needs to be put in a mirrored world object so that we don't have
// global variables!
	world_dead = true;
    }
    //    controls.update();
    updatePhysics();
    render();
}

var cylinderMesh = function( pointX, pointY )
{
    // edge from X to Y
    var direction = new THREE.Vector3().subVectors( pointY, pointX );
    var arrow = new THREE.ArrowHelper( direction, pointX );

    var edgeGeometry = new THREE.CylinderGeometry( 2, 2, direction.length(), 6, 4 );

    var edge = new THREE.Mesh( edgeGeometry, 
			       new THREE.MeshBasicMaterial( { color: 0xff00ff } ) );
    edge.rotation = arrow.rotation.clone();
    edge.position = new THREE.Vector3().addVectors( pointX, direction.multiplyScalar(0.5) );
    return edge;
}

// orientMesh from X to Y at Midpoint
function orientMesh( mesh, pointX, pointY )
{
    // edge from X to Y
    var direction = new THREE.Vector3().subVectors( pointY, pointX );
    var arrow = new THREE.ArrowHelper( direction, pointX );

    // cylinder: radiusAtTop, radiusAtBottom, 
    //     height, radiusSegments, heightSegments
    var edgeGeometry = new THREE.CylinderGeometry( 2, 2, direction.length(), 6, 4 );

    //     var edge = new THREE.Mesh( edgeGeometry, 
    //        new THREE.MeshBasicMaterial( { color: 0xff00ff } ) );
    mesh.position = new THREE.Vector3().addVectors( pointX, direction.multiplyScalar(0.5) );
    mesh.rotation = arrow.rotation.clone();
    return mesh;
}
function clear_text() {
    $("p").remove();
}
var sprite_controls = new function () {
    this.size = 50;
    this.sprite = 0;
    this.transparent = true;
    this.opacity = 0.6;
    this.colorize = 0xffffff;
    this.textcolor = "yellow";
    this.rotateSystem = true;

    this.clear = function (x,y) {
        gui.sceneOrtho.children.forEach(function (child) {
            if (child instanceof THREE.Sprite) gui.sceneOrtho.remove(child);
        })
    };

    this.draw_and_create = function (sprite,x,y,message) {
	var fontsize = 128;
	var ctx, texture,
	    spriteMaterial, 
	    canvas = document.createElement('canvas');
	ctx = canvas.getContext('2d');
	ctx.font = fontsize + "px Arial";

	// setting canvas width/height before ctx draw, else canvas is empty
	canvas.width = ctx.measureText(message).width;
	canvas.height = fontsize * 2; // fontsize * 1.5

	// after setting the canvas width/height we have to re-set font to apply!?! looks like ctx reset
	ctx.font = fontsize + "px Arial";        
	ctx.fillStyle = this.textcolor;        
	ctx.fillText(message, 0, fontsize);

	texture = new THREE.Texture(canvas);
	texture.minFilter = THREE.LinearFilter; // NearestFilter;
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial({
	    opacity: this.opacity,
	    color: this.colorize,
	    transparent: this.transparent,
	    map : texture});
	
	spriteMaterial.scaleByViewport = true;
	spriteMaterial.blending = THREE.AdditiveBlending;

        if (!sprite) {
	    sprite = new THREE.Sprite(spriteMaterial);
	}
	
	sprite.scale.set(this.size, this.size, this.size);
	sprite.position.set(x, y, 0);
	
	gui.sceneOrtho.add(sprite);
	return sprite;
    };
};

// var color_scale = d3_scale.scaleRainbow().domain([MIN_EDGE_LENGTH, mw.MAX_EDGE_LENGTH]);
// var color_scale = d3_scale.scalePlasma();

var color_scale = d3.scale.quantile().domain([mw.MIN_EDGE_LENGTH, mw.MAX_EDGE_LENGTH])
    .range(['violet', 'indigo', '#8A2BE2', 'blue', 'green', 'yellow', '#FFD700', 'orange', '#FF4500']);



function get_member_color(len) {
    if (len < mw.MIN_EDGE_LENGTH)
	return d3.rgb("black");
    else if (len > mw.MAX_EDGE_LENGTH)
	return d3.rgb("black");
    else {
	var p = (len - mw.MIN_EDGE_LENGTH) / (mw.MAX_EDGE_LENGTH - mw.MIN_EDGE_LENGTH);
	return d3.rgb(color_scale(len));
    }
}



function updatePhysics(){

    // Unfortunately, we seem to need to slow the 1/60th of a second even furhter to reduce
    // jitter...possibly this is because my forces are too high?
    //    world.step(mirroredWorld.dt*0.2);
    mw.cworld.step(mw.dt*0.2);
    var mem_cnt = 0;


    for(var i=0; i !== mw.bodies.length; i++){
	var mesh = mw.meshes[i];
	var body = mw.bodies[i];
	// HACK : somewhere here we have to deal changing the actual
	// objects.  Not sure how this will interact, but we have to do it somehow.
	// May have to break down and make a two-part model of sliding parts
	// which would have to be tested in a different webpage.

	// eventually, I must restore the coloring function here!!!

	if (mw.bodies[i].structureKind == "member") {
	    mem_cnt++;
	    var a = body.link_a;
	    var b = body.link_z;
	    var ap = a.position;
	    var bp = b.position;

	    body.position = ap.vadd(bp).scale(0.5);


	    var mid = new THREE.Vector3((ap.x+bp.x)/2,(ap.y+bp.y)/2,(ap.z+bp.z)/2);
	    mesh.up = mw.vector_up;
	    var axis = mw.vector_axis;
	    var vector = new THREE.Vector3(ap.x-bp.x,ap.y-bp.y,ap.z-bp.z);
	    mesh.position.copy(mid);

	    mesh.quaternion.setFromUnitVectors(axis, vector.clone().normalize());

	    var q = mesh.quaternion;
	    body.quaternion.set(q.x,q.y,q.z,q.w);

	    var len = ap.distanceTo(bp);
	    var cd3 = get_member_color(len);


	    var geometry = mesh.geometry;
	    
	    for(var j = 0; j < geometry.faces.length; j++) {
		geometry.faces[j].color.setStyle( cd3 );
	    }

	    mesh.geometry.verticesNeedUpdate = true;
	    mesh.geometry.elementsNeedUpdate = true;        
	    mesh.geometry.colorsNeedUpdate = true;

	} else {

	var p = body.position;
	    var p3 = new THREE.Vector3(p.x,p.y,p.z);
	    var p3 = p3.project(gui.camera);
	    var x = (p3.x*gui.renderer.getSize().width/2.0)+gui.renderer.getSize().width/2;

	    var y = (p3.y*gui.renderer.getSize().height/2.0)+gui.renderer.getSize().height/2;

	    // Experiment...
	    if (body.name && !body.name.startsWith("endpoint")) {
		body.sprite = sprite_controls.draw_and_create(body.sprite,x,y,""+body.name);
	    }

            mesh.position.copy(mw.bodies[i].position);
	    mesh.quaternion.copy(mw.bodies[i].quaternion);
	}
	
	mesh.geometry.verticesNeedUpdate = true;
	mesh.geometry.elementsNeedUpdate = true;        
	mesh.geometry.colorsNeedUpdate = true;    
   }
}
function render() {
    gui.renderer.render(gui.scene, gui.camera);
    gui.renderer.render(gui.grid_scene, gui.camera);
    gui.renderer.autoClear = false;
    // This is for the sprites....
    gui.renderer.render(gui.sceneOrtho, gui.cameraOrtho);
}

function add_ground_plane(world,scene) {

    // Create a plane
    var groundShape = new CANNON.Plane();
    var floor_position = 0;

    
    mw.GROUND_BODY = new CANNON.Body({ mass: 0, material: mw.ground_ground_cm
				    ,
				    collisionFilterGroup: mw.GROUP1,
				    collisionFilterMask: mw.GROUP1 | mw.GROUP2, 
				  });;
    mw.GROUND_BODY.addShape(groundShape);
    mw.GROUND_BODY.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
    groundShape.position = new CANNON.Vec3(0,0,0);
    mw.GROUND_BODY.name = "floor";
    world.addBody(mw.GROUND_BODY);
    
    // floor
//    mw.floorTexture = new THREE.ImageUtils.loadTexture("images/logo-white-background.png");

    mw.floorTexture.wrapS = mw.floorTexture.wrapT = THREE.RepeatWrapping; 
    mw.floorTexture.repeat.set( 10, 10 );
    var floorMaterial = new THREE.MeshBasicMaterial( { map: mw.floorTexture, side: THREE.DoubleSide } );

    floorMaterial.transparent = true;
    floorMaterial.opacity = 0.7;
    
    var floorGeometry = new THREE.PlaneGeometry(mw.playgroundDimensions.w,
						mw.playgroundDimensions.d,
						10,
						10);
    floorGeometry.position = new THREE.Vector3(0,0,0);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    var mesh = floor;
    mw.GROUND_PLANE_MESH = mesh;
    scene.add(mw.GROUND_PLANE_MESH);    
    
    return [mw.GROUND_BODY,mesh];
}


function add_obstacle(world,scene) {
    // Materials

    var num = 4;
    var mass = 3000;
    var FRACTION = 30;
    var positions = [{x:0,y:mw.INITIAL_HEIGHT,z:1},
			  {x:1,y:mw.INITIAL_HEIGHT,z:0},
			  {x:0,y:mw.INITIAL_HEIGHT,z:-1},
			  {x:-1,y:mw.INITIAL_HEIGHT,z:0}];
    for(var i = 0; i < num; i++) {
	var obstacleShape = new CANNON.Box(new CANNON.Vec3(
	    mw.obstacleSize/2,mw.obstacleSize/(2*FRACTION),mw.obstacleSize/(2*FRACTION)));
	
	OBSTACLE_BODY = new CANNON.Body({ mass: mass, material: mw.ground_ground_cm
					  ,
					  collisionFilterGroup: mw.GROUP1,
					  collisionFilterMask: mw.GROUP1 | mw.GROUP2, 
					});
	OBSTACLE_BODY.addShape(obstacleShape);

	OBSTACLE_BODY.name = "obstacle-"+i;
	OBSTACLE_BODY.structureKind = "obstacle";
	OBSTACLE_BODY.position.set(positions[i].x,positions[i].y,positions[i].z);
	OBSTACLE_BODY.angularDamping = 0.9;
	OBSTACLE_BODY.linearDamping = 0.9;

	var q = new THREE.Quaternion();
	var vector = new THREE.Vector3(positions[i].x,positions[i].y,positions[i].z);
	var axis = new THREE.Vector3(0,1,0);
	q.setFromAxisAngle(axis,i*(Math.PI/2.0));
	OBSTACLE_BODY.quaternion.set(q.x,q.y,q.z,q.w);
	

	world.addBody(OBSTACLE_BODY);
	mw.obstacles.push(OBSTACLE_BODY);

	var cubeGeo = new THREE.BoxGeometry( mw.obstacleSize,
					     mw.obstacleSize/FRACTION,
					     mw.obstacleSize/FRACTION );
	var mesh = new THREE.Mesh(cubeGeo, mw.cubeMaterial);
	mesh.name = "obstacle-"+i;
	scene.add(mesh);

	mesh.geometry.verticesNeedUpdate = true;
	mesh.geometry.elementsNeedUpdate = true;        
	mesh.geometry.colorsNeedUpdate = true;

	push_body_mesh_pair(OBSTACLE_BODY,mesh);

    }

    return [OBSTACLE_BODY,mesh];
}

function remove_non_eternal_constraints(world) {
    for(var i = 0; i < world.constraints.length; i++) {
	var c = world.constraints[i];
	if (!c["eternal"]) 
	    world.removeConstraint(c);
    }
}

var spring = [];

Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};


function vectorToString(v) {
    return "["+v.x+","+v.y+","+v.z+"]";
}
function generate_mesh_pairings_from_robot(robot,scene)
{
    var results = [];
    
    var vindex = 0;
    var mass = mw.BASIC_BODY_MASS;
    var index_map = {};

    var vertex_index = 0;

    var body_cnt = 0;
    var mem_cnt = 0;
    // This is not yet physically modeling our system.
    var size = mw.JOINT_RADIUS;
    // Totally not understanding this...

    function process_vertex(joint,v,results,geo,mat) {
	var mesh = new THREE.Mesh(geo, mat);
	mesh.name = "joint";
	mesh.castShadow = true;
	mesh.receiveShadow = true;
	results.unshift([joint,mesh]);
	body_cnt++;
    };

    //    var links_map = new Map();
    var links = [];

    for(var i = 0; i < robot.robot_joints.length; i++) {
	var joint = robot.robot_joints[i];
	process_vertex(joint,joint.position,results,mw.jointGeo,mw.jointMaterial);
    }


    // This in fact needs to be a lot more complicated...but one step at a time.
    var w = mw.MEDIAN_EDGE_LENGTH / mw.MEMBER_FRACTION;
    for(var lin in robot.robot_members) {
	var link = robot.robot_members[lin];
	var a = link.a;
	var b = link.b;
	var h = link.a.position.distanceTo(b.position);
	// Possibly this represents a memory leak.
	// When a Mesh is deallocated, it is not clear that
	// the Geometry and material are deallocated properly.
	// We might ahve to store a pointer to these objects and deallocated them
	// separately.
	var cubeGeo = new THREE.BoxGeometry( w,h,w );

	var mesh = new THREE.Mesh(cubeGeo, mw.cubeMaterial);
	mesh.position.set(a.position.x,a.position.y+20,a.position.z);
	mesh.castShadow = true;
	mesh.receiveShadow = true;
	mesh.name = "member";
	results.unshift([link.body,mesh]);
	mem_cnt++;
    }
    return results;
}


function ccw_tetrahelix_vertex(n,edge_length) {
    // TODO: memoize these functions.
    var r = (3 * Math.sqrt(3) / 10) * edge_length;
    var h = (1/Math.sqrt(10)) *edge_length;
    var theta = Math.acos(-2/3);
    // I want to make sure "B and C" land on the ground first!    
    var twist = 45*(Math.PI / 180.0);
    return new CANNON.Vec3( r * Math.cos(n*theta+twist),  r * Math.sin(n*theta+twist), n*h );
}

function add_member_spring(a,b,world) {
    var stiffness = 10;
    var damping = 0.3;
    restlength = a.position.distanceTo(b.position);
    
    var c = new CANNON.DistanceConstraint(a,b,restlength,mw.CONSTRAINT_FORCE_SMALL);
    world.addConstraint(c);
    
}


// To do a great job with this, we really need to know the
// range of possible values, but I'll fake it..
function alphabetic_name(n) {
    if (n < 26) {
	return String.fromCharCode(65+n);
    } else {
	if (n < 26*26) {
	    return alphabetic_name(Math.floor(n/26))+alphabetic_name(n % 26);
	} else {
	    return ""+n;
	}
    }
}

var joints_to_link_map = {};
function load_NTetGlussBot(world,tets,pvec) {

    // Okay, so here we need to create the geometry of the tetrahelix.
    // This could be done in a variety of ways.
    // Probably the most mathematical is to first define a vector
    // representing the center axis, and then use a formula the nth vertex.
    // Looks like some math as been worked out by R. W. Gray:
    // http://www.rwgrayprojects.com/rbfnotes/helix/helix01.html
    // I guess I will use a CounterClockWise (ccw) tetrahelix:
    // Vn = (r cos(n*theta), r sin(n*theta), n*h)

    var n = tets+3;    
    var mass = mw.BASIC_BODY_MASS;
//    world.addContactMaterial(mw.ground_ground_cm);    

    for(var i = 0; i < n; i++) {
	var v = ccw_tetrahelix_vertex(i,mw.MEDIAN_EDGE_LENGTH);
	v = v.vadd(pvec);
	var boxBody = new CANNON.Body({ mass: mass*10, material : mw.ground_ground_cm
					,
				      	collisionFilterGroup: mw.GROUP2,
					collisionFilterMask: mw.GROUP1 
				      });
	//	var boxBody = new CANNON.Body({ mass: mass});
	// We have to use a Box to get the friction to work right!
	var s = mw.JOINT_RADIUS * 0.9;
	var boxShape = new CANNON.Box(new CANNON.Vec3(s,s,s));
	//	var boxShape = new CANNON.Sphere(mw.JOINT_RADIUS);	
	boxBody.addShape(boxShape);
	boxBody.position.set(v.x,v.y,v.z);
	boxBody.mass = 1;
	boxBody.angularDamping = 0.9;
	boxBody.linearDamping = 0.9;
	boxBody.name = alphabetic_name(i);
	joints_to_link_map[boxBody.name] = {};
	mw.robot.robot_joints.push(boxBody);
	console.log("pushing joint: "+boxBody.name);
	world.addBody(boxBody);

	for(var k = 0; k < Math.min(3,i) && k < i; k++) {
	    var h = i-(k+1);

	    // Okay, here I also want to add a new body to represent the actuator
	    // This may require some roation math, but for now let me just put it
	    // in the cetner
	    var memBody = new CANNON.Body({ mass: mass, material : mw.ground_ground_cm
					    ,
					    collisionFilterGroup: mw.GROUP2,
					    collisionFilterMask: mw.GROUP1,
					  });
	    var memShape = new CANNON.Box(
		new CANNON.Vec3(mw.MEDIAN_EDGE_LENGTH/2,
				(mw.MEDIAN_EDGE_LENGTH/(2*mw.MEMBER_FRACTION*10)),
				(mw.MEDIAN_EDGE_LENGTH/(2*mw.MEMBER_FRACTION*10))));
	    memBody.addShape(memShape);
    	    memBody.position = v_avg;
	    memBody.mass = mass;
	    memBody.angularDamping = 0.80;
	    memBody.linearDamping = 0.80;

	    var b_z = mw.robot.robot_joints[i];
	    var b_a = mw.robot.robot_joints[h];
	    {
		var ap = b_a.position;
		var bp = b_z.position;

		memBody.position = ap.vadd(bp).scale(0.5);

		var mid = new THREE.Vector3((ap.x+bp.x)/2,(ap.y+bp.y)/2,(ap.z+bp.z)/2);
		var axis = mw.vector_axis;
		var vector = new THREE.Vector3(ap.x-bp.x,ap.y-bp.y,ap.z-bp.z);
		var q = new THREE.Quaternion();
		q.setFromUnitVectors(axis, vector.clone().normalize());
		memBody.quaternion.set(q.x,q.y,q.z,q.w);
	    }

	    var v_z = b_z.position;
	    var v_avg = v_z.vadd(b_a.position);
	    v_avg.scale(0.5);
	    var link = { a: b_a, b: b_z, body: memBody};
	    mw.robot.robot_members.push(link);
	    memBody.structureKind = "member";
	    memBody.link_a = b_a;
	    memBody.link_z = b_z;
	    if (b_a.name > b_z.name) {
		var t = b_a;
		b_a = b_z;
		b_z = t;
	    }
	    memBody.name = b_a.name + " " + b_z.name;
	    joints_to_link_map[b_a.name][b_z.name] = memBody;
	    world.addBody(memBody);

	    // Now we will attempt to add the endpoints
	    var endpoints = [];
	    var ep_mass = 0.1;
//	    var ep_mass = 1.0;
	    for (var j = 0; j < 2; j++) {
		var ep = new CANNON.Body({ mass: ep_mass,
//					   material : mw.ground_ground_cm,
					   collisionFilterGroup: 0,
					   collisionFilterMask: 0, 
					 });
		endpoints.push(ep);
		ep.addShape(new CANNON.Particle());
		ep.name = "endpoint-"+i+"-"+j;
		//	    ep.structureKind = "obstacle";
		var s0 = (j == 0) ? mw.MEDIAN_EDGE_LENGTH/2 : -mw.MEDIAN_EDGE_LENGTH/2;
		var s1 = -s0;
		ep.position.set(memBody.position.x,
				memBody.position.y,
				memBody.position.z);
		ep.angularDamping = 0.99;
		ep.linearDamping = 0.99;
		var pivotA = new CANNON.Vec3(0,
					     s0,
					     0);
		var pivotB = new CANNON.Vec3(0,0,0);
		var ca = new CANNON.PointToPointConstraint(memBody,pivotA,ep,pivotB,mw.CONSTRAINT_FORCE_SMALL);
		ca["eternal"] = true;
		
		world.addConstraint(ca);
		world.addBody(ep);
		var endpointShape = new THREE.SphereGeometry(mw.MEDIAN_EDGE_LENGTH/(mw.MEMBER_FRACTION*2));
		var mesh = new THREE.Mesh(endpointShape, mw.cubeMaterial);
		
		gui.scene.add(mesh);

		mesh.geometry.verticesNeedUpdate = true;
		mesh.geometry.elementsNeedUpdate = true;        
		mesh.geometry.colorsNeedUpdate = true;
		
		push_body_mesh_pair(ep,mesh);

	    }
	    memBody["endpoints"] = endpoints;
	}
    }
}



function add_robot(world,scene) {
    var pvec = new CANNON.Vec3(0,mw.INITIAL_HEIGHT,0);
    load_NTetGlussBot(world,gui.NUMBER_OF_TETRAHEDRA,pvec);
    var pairings = generate_mesh_pairings_from_robot(mw.robot,scene);
    gui.ROBOT_PAIRINGS = pairings;
    for(var i = 0; i < pairings.length; i++) {
	scene.add(pairings[i][1]);
    }
    
    // The timing here is making this asynchronous, which is not ideal...
    pairings.forEach(function (item) {
	push_body_mesh_pair(item[0],item[1]);
    });
    //
    update_constraints(mw.robot.robot_members,
		       link => {
			   return mw.MEDIAN_EDGE_LENGTH;
		       });

}


// TODO: make world local here...
function initCannon(){
    // Setup our world
    mw.cworld = new CANNON.World();
    // Add contact material to the world
    mw.cworld.addContactMaterial(mw.ground_ground_cm);
    
    mw.cworld.quatNormalizeSkip = 0;
    mw.cworld.quatNormalizeFast = false;

    mw.cworld.gravity.set(0,mw.Y_GRAVITY_FORCE,0);
    mw.cworld.broadphase = new CANNON.NaiveBroadphase();

    // Joint body
    var shape = new CANNON.Box(new CANNON.Vec3(mw.JOINT_RADIUS/2,mw.JOINT_RADIUS/2,mw.JOINT_RADIUS/2));
    gui.jointBody = new CANNON.Body({ mass: 0 });
    gui.jointBody.addShape(shape);
    gui.jointBody.collisionFilterGroup = 0;
    gui.jointBody.collisionFilterMask = 0;
    mw.cworld.addBody(gui.jointBody);
}

function add_floor() {
    var item = add_ground_plane(mw.cworld,gui.scene)
    mw.GROUND_PLANE_MESH = item[1];
    push_body_mesh_pair(item[0],item[1]);
    gui.scene.add(mw.GROUND_PLANE_MESH);
}


function add_world_to_scene(scene) {
    var pairings = gui.ROBOT_PAIRINGS;
    for(var i = 0; i < pairings.length; i++) {
	scene.add(pairings[i][1]);
    }

}



function disable_con() {
    gui.FORCE_REGIME = "DISABLE";
}
function allow_con() {
    gui.FORCE_REGIME = "NONE";    
}
function step_con() {
    gui.FORCE_REGIME = "STEP";    
}

function step_con() {
		       }

function do_test() {
    // Right now, we are just sending the current config
    var pmodel = extract_physical_node_model();
    var am = model_to_actuator_space(pmodel);
    var x = JSON.stringify(am,null,2);
    url_for_robot = $("#poseurl").val();
    $.ajax({url: url_for_robot,
	    crossDomain: true,
	    beforeSend: function(xhr){xhr.setRequestHeader('Access-Control-Allow-Origin', '*');},
	    data: x,
	    success: function(result){
		
        $("#robotcomresult").html(result);
	    },
	    error: function (request, status, error) {
//		alert(request.responseText);
	     }
	   });

}
		       

function updateMouseConstraints(body) {
        // Now we want to disable all attached length constraints (and actually add others)
    for(var i = 0; i < mw.cworld.constraints.length; i++) {
	var c = mw.cworld.constraints[i];
	if (c.name != "mouseConstraint"){
	// Possibly we don't want to really disable these, but weaken them.
	if (gui.FORCE_REGIME == "STEP") {
	    var d = c.bodyA.position.distanceTo(c.bodyB.position);

	    var dp = Math.max(Math.min(d,mw.MAX_EDGE_LENGTH),mw.MIN_EDGE_LENGTH);
	    var f;
	    // r should be 1.0 when at the edge.

	    // NOTE: This approach is fundamentally limited, and probably conceptually wrong!
	    // The string of the spring should not increase as we exceed the length!!!
	    // THIS IS FUNDAMENTALLY WRONG.
	    var r = (d - mw.MEDIAN_EDGE_LENGTH)/ ((mw.MAX_EDGE_LENGTH - mw.MIN_EDGE_LENGTH)/ 2);

	    r = Math.max(r,0.4);
	    var f = mw.CONSTRAINT_FORCE_SMALL*Math.pow(r,2);
	    if (!c["eternal"]) 
		mw.cworld.removeConstraint(c);
	    var n = new CANNON.DistanceConstraint(c.bodyA,c.bodyB,dp,f);
	    world.addConstraint(n);

	} else if (gui.FORCE_REGIME == "DISABLE") {
	    if (((c.bodyA == body) || (c.bodyB == body))
		&& (!(c.bodyA.name.startsWith("endpoint") || c.bodyB.name.startsWith("endpoint") ))
	       ) {
		
		c.disable();
	    }
	} else if (gui.FORCE_REGIME == "NONE") {
	}
	}
    }
}

function addMouseConstraint(x,y,z,body) {
    // The cannon body constrained by the mouse joint
    var constrainedBody = body;

    // Vector to the clicked point, relative to the body
    var v1 = new CANNON.Vec3(x,y,z).vsub(constrainedBody.position);

    // Apply anti-quaternion to vector to tranform it into the local body coordinate system
    var antiRot = constrainedBody.quaternion.inverse();
    pivot = antiRot.vmult(v1); // pivot is not in local body coordinates

    // Move the cannon click marker particle to the click position
    gui.jointBody.position.set(x,y,z);

    updateMouseConstraints(body);

    // Create a new constraint
    // The pivot for the gui.jointBody is zero
    gui.mouseConstraint = new CANNON.PointToPointConstraint(constrainedBody, pivot, gui.jointBody, new CANNON.Vec3(0,0,0));
    gui.mouseConstraint.name = "mouseConstraint";
    gui.mouseConstraint.attachedBody = body;


    // Add the constriant to world
    mw.cworld.addConstraint(gui.mouseConstraint);
    // We want to turn gravity offf while we are editing....
    mw.cworld.gravity.set(0,0,0);
}




// This functions moves the transparent joint body to a new postion in space

function moveJointToPoint(x,y,z) {
    // Move the joint body to a new position
    gui.jointBody.position.set(x,y,z);


    var body = gui.mouseConstraint.attachedBody;
    
    var w = mw.MEDIAN_EDGE_LENGTH / mw.MEMBER_FRACTION;

    for(var i = 0; i < mw.bodies.length; i++) {
	var bx = mw.bodies[i];
	var mx = mw.meshes[i];
	if (bx.structureKind == "member") {
	    var a = bx.link_a;
	    var b = bx.link_z;

	    if ((a == body) || ( b == body)) {
		// HERE is where we must deal with the mesh changing sizes, not in update physics.
		var ap = a.position;
		var bp = b.position;
		var len = ap.distanceTo(bp);
		
		var cd3 = d3.rgb(color_scale(len));
		
		var d = len;
		
		var h = a.position.distanceTo(b.position);
		var cubeGeo = new THREE.BoxGeometry( w,h,w );

		var mesh = new THREE.Mesh(cubeGeo, mw.cubeMaterial);

		gui.scene.remove(mw.meshes[i]);
		gui.scene.add(mesh);
		mw.meshes[i] = mesh;
		for(var j = 0; j < mesh.geometry.faces.length; j++) {
    		    mesh.geometry.faces[j].color.setStyle( color_scale(d) );
		}
		
		mesh.position.set(a.position.x,a.position.y,a.position.z);
		mesh.castShadow = true;
		mesh.receiveShadow = true;
		
		mesh.geometry.verticesNeedUpdate = true;
		mesh.geometry.elementsNeedUpdate = true;        
		mesh.geometry.colorsNeedUpdate = true;

	    }
	}
	//	}	
	
    }

    updateMouseConstraints(null);
    gui.mouseConstraint.update();
}

function render_constraints() {
    for(var i = 0; i < mw.cworld.constraints.length; i++) {
	var c = mw.cworld.constraints[i];
	console.log("("+c.bodyA.name+","+c.bodyB.name+") = "+c.distance);	    	
    }
}

function removeJointConstraint() {
    // Remove constriant from world
    if (!gui.mouseConstraint) {
	return;
    }
    mw.cworld.removeConstraint(gui.mouseConstraint);
    // Now we want to disable all attached length constraints (and actually add others)

    var body = gui.mouseConstraint.attachedBody;
    if (body) {
	
	for(var i = 0; i < mw.cworld.constraints.length; i++) {
	    var c = mw.cworld.constraints[i];
		var newrestlength = c.bodyA.position.distanceTo(c.bodyB.position);
		// HACK: This is an experiment...
		if (auto_rectify_on) {
		    newrestlength = Math.max(Math.min(newrestlength,mw.MAX_EDGE_LENGTH),mw.MIN_EDGE_LENGTH);
		}
		c.distance = newrestlength;
		c.update();
		c.enable();	    
	}
    }
    gui.mouseConstraint = false;

    // Turn gravity back on...
    // We want to turn gravity offf while we are editing....
    if (gui.gravity_on) {
	mw.cworld.gravity.set(0,mw.Y_GRAVITY_FORCE,0);
    }
    update_constraints(mw.robot.robot_members,link => {
	var a = link.a;
	var b = link.b;
	var d = a.position.distanceTo(b.position);
	return d;
    });

}

function render_physical_model(id) {
    var pmodel = extract_physical_node_model();
    var command = $("#pmodel").val(JSON.stringify(pmodel,null,2));
}

function send_pose_to_robot() {
    alert("Yes, I will send!");
}

// This is now rendering in an "emacs-ready" way --- that needs to be
// made clear.
function render_actuator_model(form) {
    var pmodel = extract_physical_node_model();
    
    var am = model_to_actuator_space(pmodel);
    var x = JSON.stringify(am,null,2);
    if (form === 'escaped')
	x = '"'+x.replace(/"/gi,'\\"')+'"';
    var command = $("#amodel").val(x);
}
function get_body_by_name(name) {
    for(var i = 0; i < mw.bodies.length; i++) {
	var bx = mw.bodies[i];
	if ((bx.structureKind != "member") && (bx.name != "floor")) {
	    if (bx.name == name) {
		return bx;
	    }
	}
    }
}
function set_constraints(am) {
    update_constraints(mw.robot.robot_members,link => {
	var e = actuator_to_length(am[key]);	
	return e;
    });
    mw.most_recent_constraints = am;
}

function interp(x,y,frac) {
    return x + (y-x)*frac;
}
function set_interp_constraints(am0,am1,frac) {
    remove_non_eternal_constraints(mw.cworld);
    var links = [];
    for (var key in am0) {
	if (am1.hasOwnProperty(key)) {
	              var link  = find_bodies_from_actuator(key);
            var a = get_body_by_name(link[0]);
            var b = get_body_by_name(link[1]);

            var d = a.position.distanceTo(b.position);
	    links.push({a: a, b: b, k: key });
	}
    }
   update_constraints(links,link => {
       var a = link.a;
       var b = link.b;
       var key = link.k;
       var e = actuator_to_length(interp(am0[key],am1[key],frac));
       return e;
    });

    mw.most_recent_contraints = am1;
}

function rectify(id) {
    var pmodel = extract_physical_node_model();
    
    var am = model_to_actuator_space(pmodel);

    for (var key in am) {
	if (am.hasOwnProperty(key)) {
	    am[key] = Math.min(Math.max(am[key],0),1023);
	}
    }
    set_constraints(am);
}

function load_pose(id) {
    var pose_string = $("#amodel").val();

    var unescaped = pose_string.replace(/\\\"/g,"\"");
    
    var actuator_model = JSON.parse(unescaped);
    
    set_constraints(actuator_model);
}

function name_pose(id) {
    var pmodel = extract_physical_node_model();
    var am = model_to_actuator_space(pmodel);
    var name = $("#posename").val();
    var pose = {};
    pose["type"] = "pose";
    pose["name"] = name;
    pose["geometry"] = "5TetGlussBot";
    pose["pose"] = am;
    console.log(pose);
    localStorage.setItem(name, JSON.stringify(am));
    update_poses();
}

function set_named_pose(id) {
    var pose = localStorage.getItem(localStorage.key(id));
    var constraints = JSON.parse(pose);
    execute(gui.standard_ctx,mw.most_recent_contraints,execute_atom,constraints.pose,gui.GAIT_SUBDIVISIONS,gui.TIME_BETWEEN_POSES_MS);
}
function set_standard_pose(num) {
    var pose = gui.standard_objs[num];
    var constraints = pose.pose;
    execute(gui.standard_ctx,mw.most_recent_contraints,execute_atom,pose.pose,gui.GAIT_SUBDIVISIONS,gui.TIME_BETWEEN_POSES_MS);
}
function set_standard_gait(num) {
    var gait = gui.standard_objs[num];
    execute(gui.standard_ctx,mw.most_recent_contraints,execute_atom,gait.gait,gui.GAIT_SUBDIVISIONS,gui.TIME_BETWEEN_POSES_MS);
}

// This is section implements the Gluss Programming Language 0.1 (GLPL). A program is called a GLOG.
// This should probably be broken out into a different file.  The basic concept
// is that GLPL is a valid JSON object.  Here is a BNF, although since this is in JSON
// we basically will do "parsing".
// <glog> ::= <array> | <object>
// <object> ::= <def> | <com>
// <def> ::= <pose> | <gait>
// <pose> ::= Object whose "type" is "pose" and has "pose" property | <string>
// <gait> ::= Object whose "type is "gait" and has "gait" property, which is a glog
// <array> ::= '[' <list> ']'
// <list> ::= <glog> | <list> , <glog>
// <com> ::= <string> | <ex-pose>
// <ex-pose> ::= object which does not have "name" as a property
// In other words, a GLOG is an array of GLOGs or an object, and an object pose or a gait,
// and a gait is a GLOG.  So this is a language with no conditionals, not input, no loops.
// Not that in when a <string> is a <pose>, it potentially must be resolvable by definitions
// some where else.
// Following the concept I learned back at Rice University in '86, the language has a "context"
// which is mainly a dictionary of known defintions for strings.  Execution can return a context
// which adds a defintion to the context.  All of this is easier in LISP, of course. In this case
// we will use an object that maps names to GLOGs as the context
// So the 0.1 version is really astounding simple.  The main thing we have to be able to do
// is to process it into an executable pose and the remainding GLOG.

// This function returns [first,rest] (meaning a two-element array, where rest may not be an atom)
// It guarantees that the first is a executable command or an defintion (and that rest coorectly
// takes into account the fact that the head of the glog might not be atomic.
// Note that the context is an object that maps names to definitions.

// So the equestion is should this return a pose?  I think yes---the goal here is
// that this function expands all the way to a pose.  If a string is found,
// it must be expanded in context, and the "rest" part properly filled out.
function get_first_executable(ctx,glog) {
    if (Array.isArray(glog)) {
	if (glog.length == 0) {
	    return [glog,[]];
	} else if (glog.length == 1) {
	    return get_first_executable(ctx,glog[0]);	    
	} else {
	    // Okay, so how to handle the resulting arg here is a little tricky....
	    var res = get_first_executable(ctx,glog[0]);
	    var rest = [];
	    rest[0] = res[0];
	    rest[1] = res[1].concat(glog.slice(1));
	    return rest;
	}
    } else { // So we are either a definition of a command, either way we just package and are done.
	// Now if we are a string, we look it up in the context and expand..
	if (typeof glog == "string") {
	    var def = ctx[glog];
	    if (typeof def == 'undefined') { // didn't find it,
		console.log("Couldn't find string in context:" + glog);
		console.log("Context:" + ctx);
	    } else {
		if (def.type == "pose") {
		    var rest = [];
		    rest[0] = def.pose;
		    rest[1] = [];
		} else if (def.type == "gait") {
		    var prog = def.gait; // This should be a glog!!
		    return get_first_executable(ctx,prog);
		}
		return rest;
	    }
	} else { // Presumably it is a pose, we should probably check that...
	    for(var k in glog) {
		var val = glog[k];
		var num;
		if (typeof val == "string") {
		    console.log("converting string to int: "+val);
		    num = parseInt(val);
		} else if (typeof val == "number")  {
		    num = val;
		} else {
		    console.log("Couldn't intepret: "+val);
		}
		// Possibly we should put a value test in here?
		glog[k] = num;
	    }
	    return [glog,[]];
	}
    }
}

// Real glogs have internal stucture we don't care about...so we can test with non-glogs..
function test_get_first_executable_0() {
    var ex0 = [[{A: 0},{A: 1}],[{A: 2}]];
    var res0 = get_first_executable(null,ex0);
    var f0 = res0[0];
    if (f0.A != 0)
	return false;
    var res1 = get_first_executable(null,res0[1]);
    var f1 = res1[0];
    if (f1.A != 1)
	return false;
    var res2 = get_first_executable(null,res1[1]);
    var f2 = res2[0];
    if (f2.A != 2)
	return false;
    if (res2[1].length != 0)
	return false;
    return true;
}

function glog_is_atom(glog) {
    return !(Array.isArray(glog));
}
function glog_is_definition(glog) {
    return (glog["type"] == "pose" || glog["type"] == "gait");
}
function glog_is_executable(glog) {
    return glog_is_atom(glog) && !glog_is_definition(glog);
}

function execute_atom(ctx,cur,atom,subdivisions,time_between_poses_ms) {
    var intertick = time_between_poses_ms / subdivisions;
    if (!cur) {
	cur = atom;
    }

    for(var j = 0; j < subdivisions; j++) {
	setTimeout(function(am0,am1,frac) {
	    set_interp_constraints(am0,am1,frac);
	},
	   j*intertick,
		   cur,
	   atom,
	   j/(subdivisions*1.0)
	  );
    }
}

function execute(ctx,initial,execute_atom,glog,subdivisions,time_between_poses_ms) {
    // if glog is an empty array or null, there is nothing to do.
    if (glog_is_atom(glog)) {
	if (glog_is_executable(glog)) {
	    execute_atom(ctx,initial,glog,subdivisions,time_between_poses_ms);
	}
    }
    var wait_time = time_between_poses_ms/subdivisions;
    var res0 = get_first_executable(ctx,glog);
    var first = res0[0];
    execute_atom(ctx,initial,first,subdivisions,time_between_poses_ms);
    var rest = res0[1];
    if (rest.length > 0) {
	setTimeout(function(r) {
	    execute(ctx,first,execute_atom,rest,subdivisions,time_between_poses_ms);
	},
		   time_between_poses_ms,
		   rest
		   );
    }
}
function execute_atom_dummy(ctx,glog) {
    console.log("atom"+glog);
}

function test_execute_0() {
    var glog = [{"A0":800,"A1":400,"A2":236,"A3":0,"A4":1000,"A5":0,"B0":500,"B1":500,"B2":1000,"B3":0,"B4":600,"B5":1000,"C0":200,"C1":1000,"C2":500,"C3":969,"C4":500,"C5":200},
		{"A0":800,"A1":400,"A2":236,"A3":500,"A4":1000,"A5":500,"B0":500,"B1":500,"B2":450,"B3":0,"B4":600,"B5":500,"C0":300,"C1":200,"C2":200,"C3":969,"C4":500,"C5":200}];
    execute(gui.standard_objs,mw.most_recent_contraints,execute_atom_dummy,glog,10,1000);
}

function test_execute_1() {
    var glog = [{"A0":800,"A1":400,"A2":236,"A3":0,"A4":1000,"A5":0,"B0":500,"B1":500,"B2":1000,"B3":0,"B4":600,"B5":1000,"C0":200,"C1":1000,"C2":500,"C3":969,"C4":500,"C5":200},
		{"A0":800,"A1":400,"A2":236,"A3":500,"A4":1000,"A5":500,"B0":500,"B1":500,"B2":450,"B3":0,"B4":600,"B5":500,"C0":300,"C1":200,"C2":200,"C3":969,"C4":500,"C5":200}];
    execute(gui.standard_objs,mw.most_recent_contraints,execute_atom,glog,10,1000);
}

function generate_context_from_standard(objects) {
    var ctx = {};
    for (var i = 0; i < objects.length; i++){
	var obj = objects[i];
	if (obj.type == "pose") {
	    ctx[obj.name] = obj;
	} else if (obj.type == "gait") {
	    ctx[obj.name] = obj;	    
	}
    }
    return ctx;
}


function test_execute_2() {
    var n0 = gui.standard_objs[5].name;
    var n1 = gui.standard_objs[6].name;
    var glog = [n0,n1];
//    gui.standard_ctx = generate_context_from_standard(standard_objs);
    execute(gui.standard_ctx,mw.most_recent_contraints,execute_atom,glog,10,1000);
}

function test_execute_3() {
    var glog = ["thinwalk"];
//    gui.standard_ctx = generate_context_from_standard(gui.standard_objs);
    execute(gui.standard_ctx,mw.most_recent_contraints,execute_atom,glog,10,1000);
}

// The purpose of this is to return the context with more definitions...
function execute_definitions(ctx,glog) {
}



function update_poses() {
    var names = "";
    for (var i = 0; i < localStorage.length; i++){
	names += '<button type="button" onclick="set_named_pose('+i+')">' + localStorage.key(i) + '</button>';

    }
    $("#poslist").html(names);
}

function update_standard_poses() {
    var poses = "";
    var gaits = "";    
    for (var i = 0; i < gui.standard_objs.length; i++){
	var obj = gui.standard_objs[i];
	if (obj.type == "pose") {
	    poses += '<button type="button" onclick="set_standard_pose('+i+')">' + gui.standard_objs[i].name + '</button>';
	} else if (obj.type == "gait") {
	    gaits += '<button type="button" onclick="set_standard_gait('+i+')">' + gui.standard_objs[i].name + '</button>';
	}
    }
    $("#stdposes").html(poses);
    $("#stdgaits").html(gaits);    
}



// Need to expand this machinergy so that at any time we can process
// a pose or a gait mixed generically.

function execute_gait() {
    var gait = $("#gait").val();
    var pose_names = gait.trim().split(" ");
    var initial = get_first_executable(gui.standard_ctx,pose_names[0]);
    execute(gui.standard_ctx,initial[0],execute_atom,pose_names,gui.GAIT_SUBDIVISIONS,gui.TIME_BETWEEN_POSES_MS);
}

// Eventually this should be a linear interpolation of the models of frace from m1 to m2
function interpolate_model(m1,m2,frac) {
    console.assert(m1.length == m2.length,m1);
    var v = {};
    for (var key in m1) {
	if (m1.hasOwnProperty(key)) {
	    var iv = m1[key] + (m2[key] - m1[key])*frac;
	    v[key] = iv;
	}
    }
    console.log(v);
    return v;
}

function extract_physical_node_model() {
    var nodes = [];
    for(var i = 0; i < mw.bodies.length; i++) {
	var bx = mw.bodies[i];
	if ((bx.structureKind != "member") && (bx.name != "floor")) {
	    nodes.push({ name: bx.name,
			 position: new CANNON.Vec3(bx.position.x,bx.position.y,bx.position.z) });
	}
    }
    return nodes;
}

// Here I am developing some "poses" for fun.
// This may allow us to simulate a gait.
// This will require us to cross-reference the emacs-ctl.el file and
// begin integration with that.
// A pose exists in Actuator space rather than in cartesian space.
var lo = 0;
var mid = 450;
var hi = 900;

var flat_pose = { A0: 0, A1: 100+mid, A2: 100+mid, A3: 300+lo, A4: mid, A5: mid,
		  B0: 0, B1: 100+mid, B2: 100+mid, B3: 300+lo, B4: mid, B5: mid};

var actuator_to_length = d3.scale.linear().domain([0,1023]).range([mw.MIN_EDGE_LENGTH,mw.MAX_EDGE_LENGTH]);

function flat() {
    assume_pose(flat_pose);
}

// TODO: This is not using the argument --- something is terribly wrong.
function model_to_actuator_space(bodies) {
    var pose = {};

    for(var lin in mw.robot.robot_members) {
	var mem = mw.robot.robot_members[lin];  
	var a = mem.a;
	var b = mem.b;
	// invert actually returns strings, for some reason, probably for css...
	var d = parseInt(actuator_to_length.invert(a.position.distanceTo(b.position)).toFixed(0));
	var actuator_name = find_actuator(a.name,b.name);
	pose[actuator_name] = d;
    }

    return pose;
}

function half_size() {
    factor_size(0.5);
}

function double_size() {
    factors_size(2.0);
}

function big_size() {
    fixed_size(mw.MAX_EDGE_LENGTH);
}
function small_size() {
    fixed_size(mw.MIN_EDGE_LENGTH);
}


function toggle_gravity() {
    if (gui.gravity_on) {
	gui.gravity_on = false;
	mw.cworld.gravity.set(0,0,0);	
	$("#gravity_ctl").html("Turn Gravity On");
    } else {
	gui.gravity_on = true;
	mw.cworld.gravity.set(0,mw.Y_GRAVITY_FORCE,0);
	$("#gravity_ctl").html("Turn Gravity Off");
    }
}

var auto_rectify_on = false;
function auto_rectify_toggle() {
    if (auto_rectify_on) {
	auto_rectify_on = false;
	$("#auto_rectify_ctl").html("Turn Auto Rectify On");	
    } else {
	auto_rectify_on = true;
	$("#auto_rectify_ctl").html("Turn Auto Rectify Off");	
    }
}
var fudge = 0.1;
function update_constraints(links,f) {
    remove_non_eternal_constraints(mw.cworld);
    for(var lin in links) {
	var link = links[lin];  
	var a = link.a;
	var b = link.b;
	if (a.name > b.name) {
	    var t = a;
	    a = b;
	    b = t;
	}
	var d = f(link);
	var c = new CANNON.DistanceConstraint(a,b,d,mw.CONSTRAINT_FORCE_LARGE);
	mw.cworld.addConstraint(c);
	// now we want to find the Cannon Object associated with these links,
	// and put a distance constraint between the member object and the two
	// joint objects.
	var mem = joints_to_link_map[a.name][b.name]
	if (!mem) {
	    console.log("Can't find a.name, b.name "+a.name + b.name);
	}
//	if (mw.obstacles.length > 0) {
//	if (a.name == "C" && b.name == "D") {
	    var s = (d/2);
	    var memShape = mem.shapes[0];
	    memShape.halfExtents.set(s,
				     mw.MEDIAN_EDGE_LENGTH/(2*mw.MEMBER_FRACTION),
				     mw.MEDIAN_EDGE_LENGTH/(2*mw.MEMBER_FRACTION));
	    memShape.updateConvexPolyhedronRepresentation();
	    mem.computeAABB();
	    {

		// Note that the member links are coonected at the ends of the "z" axis.

		// I have no idea why this should be done on the Y axis -- it must
		// be some weird internal manipulation of the objects that is occuring before
		// we get it, might have to look at quaternions!!!!
		var pivotMEM = new CANNON.Vec3(0,s,0);
		var pivotA = new CANNON.Vec3(0,0,0);
		//		var ca = new CANNON.PointToPointConstraint(a,pivotA,mem,pivotMEM,mw.CONSTRAINT_FORCE_SMALL);
		var ca = new CANNON.DistanceConstraint(a,mem.endpoints[0],0,mw.CONSTRAINT_FORCE_LARGE);
		mw.cworld.addConstraint(ca);

	    }
	    // Note that the member links are coonected at the ends of the "z" axis.
	    {

		// I have no idea why this should be done on the Y axis -- it must
		// be some weird internal manipulation of the objects that is occuring before
		// we get it, might have to look at quaternions!!!!
		var pivotMEM = new CANNON.Vec3(0,-s,0);
		var pivotA = new CANNON.Vec3(0,0,0);
//		var ca = new CANNON.PointToPointConstraint(b,pivotA,mem,pivotMEM,mw.CONSTRAINT_FORCE_SMALL);
		var ca = new CANNON.DistanceConstraint(b,mem.endpoints[1],0,mw.CONSTRAINT_FORCE_LARGE);
		mw.cworld.addConstraint(ca);
	    }
//	}
//	}
    }
}


function update_constraints_orig(links,f) {
    remove_non_eternal_constraints(mw.cworld);
    for(var lin in links) {
	var link = links[lin];  
	var a = link.a;
	var b = link.b;
	if (a.name > b.name) {
	    var t = a;
	    a = b;
	    b = t;
	}
	var d = f(link);
	var c = new CANNON.DistanceConstraint(a,b,d,mw.CONSTRAINT_FORCE_LARGE);
	mw.cworld.addConstraint(c);
	// now we want to find the Cannon Object associated with these links,
	// and put a distance constraint between the member object and the two
	// joint objects.
	var mem = joints_to_link_map[a.name][b.name]
	if (!mem) {
	    console.log("Can't find a.name, b.name "+a.name + b.name);
	}

	var s = (d/2);
	var memShape = mem.shapes[0];
	memShape.halfExtents.set(s,
				 mw.MEDIAN_EDGE_LENGTH/(2*mw.MEMBER_FRACTION),
				 mw.MEDIAN_EDGE_LENGTH/(2*mw.MEMBER_FRACTION));
	memShape.updateConvexPolyhedronRepresentation();

	mem.computeAABB();

	{
	    // I have no idea why this should be done on the Y axis -- it must
	    // be some weird internal manipulation of the objects that is occuring before
	    // we get it, might have to look at quaternions!!!!
	    var pivotMEM = new CANNON.Vec3(0,s,0);
	    var pivotA = new CANNON.Vec3(0,0,0);
	    var ca = new CANNON.PointToPointConstraint(a,pivotA,mem,pivotMEM,mw.CONSTRAINT_FORCE_SMALL);
	    mw.cworld.addConstraint(ca);
	}
	{
	    // I have no idea why this should be done on the Y axis -- it must
	    // be some weird internal manipulation of the objects that is occuring before
	    // we get it, might have to look at quaternions!!!!
	    var pivotMEM = new CANNON.Vec3(0,-s,0);
	    var pivotA = new CANNON.Vec3(0,0,0);
	    var ca = new CANNON.PointToPointConstraint(b,pivotA,mem,pivotMEM,mw.CONSTRAINT_FORCE_SMALL);
	    mw.cworld.addConstraint(ca);
	}
    }
}

function factor_size(f) {
    update_constraints(mw.robot.robot_members,link => {
	var a = link.a;
	var b = link.b;
	var d = a.position.distanceTo(b.position);
	return d*f;
    });
}

function fixed_size(s) {
    update_constraints(mw.robot.robot_members,link => {
	return s;
    });

}


function assume_pose(pose) {

    update_constraints(mw.robot.robot_members,link => {
	var d = actuator_to_length(pose[act]);
	return d;
    });
    
    var STEPS_TO_TAKE = 30;
    for(var j = 0; j < STEPS_TO_TAKE; j++) {
	updatePhysics();
    }
}


// To support bigger robots, I will have to allow numbering of these things.
// This patten can be repeated.  Basically we order the links in the order in
// which we fill in the nodes...
// Not that this CANNOT be fully regular, since we must adjust at the
// terminus based on the length, where we must break the patterns.
// An alternative pattern would be to make the first tetradra irregular.
// That is perhaps more sensible than what we have here.  Then each
// additional controller can be added in a completely regular way.


// These are now obsolete and must be removed!!

var ACTUATORS_PER_CONTROLLER = 6;
function actuator_name_from_number(n) {
    var controller = Math.floor(n / ACTUATORS_PER_CONTROLLER);
    var controller_name = alphabetic_name(controller);
    var digit = n % ACTUATORS_PER_CONTROLLER;
    return controller_name + digit;
}
function compute_body_number(name) {
    if (name.length > 1) {
	debugger;
    }
    return name.charCodeAt(0) - 65;
}

// return a pair of body names
function find_bodies_from_actuator(name) {
    var c = name.charCodeAt(0) - 65;
    var d = name.charCodeAt(1) - "0".charCodeAt(0);
    var n = ACTUATORS_PER_CONTROLLER * c + d;
    if (n < 6) {
	if (n == 0) {
	    return [alphabetic_name(0),alphabetic_name(1)];	    
	} else if (n == 1) {
	    return [alphabetic_name(0),alphabetic_name(2)];	    
	} else if (n == 2) {
	    return [alphabetic_name(0),alphabetic_name(3)];	    
	} else if (n == 3) {
	    return [alphabetic_name(1),alphabetic_name(2)];	    
	} else if (n == 4) {
	    return [alphabetic_name(2),alphabetic_name(3)];	    
	} else if (n == 5) {
	    return [alphabetic_name(3),alphabetic_name(1)];	    
	}
    } else {
	var hi = Math.floor((n - 6) / 3)+4;
	var lo = hi - (3 -  (n % 3));
    return [alphabetic_name(lo),alphabetic_name(hi)];
}

}
function test_find_bodies_from_actuator() {
    
    for(var i = 0; i < ACTUATORS_PER_CONTROLLER; i++) {
	var a = "A"+i;
	var bs = find_bodies_from_actuator(a);
	var ap = find_actuator(bs[0],bs[1]);
	if (ap != a) debugger;
    }
    
    for(var i = 0; i < ACTUATORS_PER_CONTROLLER; i++) {
	var a = "B"+i;
	var bs = find_bodies_from_actuator(a);
	var ap = find_actuator(bs[0],bs[1]);
	if (ap != a) debugger;
    }

    for(var i = 0; i < ACTUATORS_PER_CONTROLLER; i++) {
	var a = "G"+i;
	var bs = find_bodies_from_actuator(a);
	var ap = find_actuator(bs[0],bs[1]);
	if (ap != a) debugger;
    }

}

// a and b are node names.
function find_actuator(a,b) {
    if (a == b)
	debugger;

    if (b < a) {
	var t = a;
	a = b;
	b = t;
    }
    
    // Without loss of generality, a < b.
    var n;
    if (b <= "D") {
	if ((a == "A") && (b == "B")) {
	    n = 0; 
	} else if ((a == "A") && (b == "C")) {
	    n = 1;
	} else if ((a == "A") && (b == "D")) {
	    n = 2;
	} else if ((a == "B") && (b == "C")) {
	    n = 3;
	} else if ((a == "C") && (b == "D")) {
	    n = 4;
	} else if ((a == "B") && (b == "D")) {
	    n = 5;
	}
    } else {
	var k = compute_body_number(a);
	var h = compute_body_number(b);
	if ((h - k) > 3) {
	    debugger;
	}
	n = 3 * ( h - 2 ) + (3 - (h - k));
    }
    return actuator_name_from_number(n);
}

function test_find_actuator() {
    var x0 = find_actuator("A","B");
    if (x0 != "A0")
    {
	debugger;
    }
    var x1 = find_actuator("E","B");
    if (x1 != "B0") {
	debugger;
    }
    var x2 = find_actuator("E","C");
    if (x2 != "B1") {
	debugger;
    }
    var x3 = find_actuator("F","E");
    if (x3 != "B5") {
	debugger;
    }
}


// Compute the actuator name between the two 
function actuator(b1,b2) {
    return find_actuator(b1,b2);
}

// Compute the actuator name between the two 
function regenerate() {
    for(var i = 0; i < mw.bodies.length; i++) {
	var bx = mw.bodies[i];
	var mx = mw.meshes[i];
	if (bx.name != "floor") {
	    gui.scene.remove(mw.meshes[i]);
	}
    }

    var pairings = generate_mesh_pairings_from_robot(mw.robot,gui.scene);
    for(var i = 0; i < pairings.length; i++) {
	gui.scene.add(pairings[i][1]);
    }

    clear_non_floor_body_mesh_pairs();
    
    // The timing here is making this asynchronous, which is not ideal...
    pairings.forEach(function (item) {
	push_body_mesh_pair(item[0],item[1]);
    });

    var STEPS_TO_TAKE = 3;
    for(var j = 0; j < STEPS_TO_TAKE; j++) {
	updatePhysics();
    }
}

// Initialize Three.js
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

// remove_robot and remove_world are dead code but useful for creating
// proper objects in the future.
function remove_robot() {
    mw.meshes = [];
    mw.bodies = [];
    mw.robot.robot_joints = [];
// This is the cannon.js robot members.
    mw.robot.robot_members = [];
}

function remove_world() {
    mw.world_live = false;
    while (gui.world_container.get()[0].hasChildNodes()) {   
	gui.world_container.get()[0].removeChild(gui.world_container.get()[0].firstChild);
    }

    remove_robot();

    gui.jointBody = null;

    gui.mouseConstraint = null;

    gui.container = null;
    gui.camera = null;
    gui.scene = null;
    gui.renderer = null;
    gui.projector = null;

    gui.grid_scene = null;

    gui.cameraOrtho = null;
    
    sprite_controls.clear();
    
    gui.sceneOrtho = null;
    gui.gplane=false;
    gui.clickMarker=false;

    mw.meshes = [];
    mw.bodies = [];
    mw.GROUND_PLANE_MESH = null;
    mw.GROUND_BODY = null;
}

function build_world() {
    var scene = init_scene();
    gui.scene = scene;
    initCannon();
    add_floor();
    add_robot(mw.cworld,scene);
    add_obstacle(mw.cworld,scene);

    update_constraints(mw.robot.robot_members,
		       link => {
			   return mw.MEDIAN_EDGE_LENGTH;
		       });

    finish_scene_preparation(scene);
    update_poses();
    mw.world_live = true;
    animate();
}

build_world();

function reset_to_default() {
    remove_world();
    build_world();
}

$(document).on('click', '.panel-heading span.clickable', function(e){
    var $this = $(this);
    if(!$this.hasClass('panel-collapsed')) {
	$this.parents('.panel').find('.panel-body').slideUp();
	$this.addClass('panel-collapsed');
	$this.find('i').removeClass('glyphicon-chevron-up').addClass('glyphicon-chevron-down');
    } else {
	$this.parents('.panel').find('.panel-body').slideDown();
	$this.removeClass('panel-collapsed');
	$this.find('i').removeClass('glyphicon-chevron-down').addClass('glyphicon-chevron-up');
    }
});

$('.panel-heading span.clickable').click();


//----------------------------------------------------------------------------
// opts
// {
//  height: width, 
//  width: depth,
//  linesHeight: b,
//  linesWidth: c,
//  color: 0xcccccc
// }
//
//____________________________________________________________________________
function createAGrid(opts) {
  var config = opts || {
    height: 500,
    width: 500,
    linesHeight: 10,
    linesWidth: 10,
    color: 0xDD006C
  };

  var material = new THREE.LineBasicMaterial({
    color: config.color,
      opacity: 0.2,
      linewidth: 2
  });

  var gridObject = new THREE.Object3D(),
    gridGeo = new THREE.Geometry(),
    stepw = 2 * config.width / config.linesWidth,
    steph = 2 * config.height / config.linesHeight;

  //width
  for (var i = -config.width; i <= config.width; i += stepw) {
    gridGeo.vertices.push(new THREE.Vector3(-config.height, i, 0));
    gridGeo.vertices.push(new THREE.Vector3(config.height, i, 0));

  }
  //height
  for (var i = -config.height; i <= config.height; i += steph) {
    gridGeo.vertices.push(new THREE.Vector3(i, -config.width, 0));
    gridGeo.vertices.push(new THREE.Vector3(i, config.width, 0));
  }

  var line = new THREE.Line(gridGeo, material, THREE.LinePieces);
  gridObject.add(line);

  return gridObject;
}

function labelAxis(width, data, direction){

  var separator = 2*width/data.length,
			p = {
				x:0,
				y:0,
				z:0
			},
			dobj = new THREE.Object3D();

  for ( var i = 0; i < data.length; i ++ ) {
      var label = makeTextSprite(data[i],{fontsize: 50 });

		label.position.set(p.x,p.y,p.z);

		dobj.add( label );
		if (direction=="y"){
			p[direction]+=separator;
		}else{
			p[direction]-=separator;
		}

  }
  return dobj;
}


// This was written by Lee Stemkoski
// https://stemkoski.github.io/Three.js/Sprite-Text-Labels.html
function makeTextSprite( message, parameters )
{
	if ( parameters === undefined ) parameters = {};

	var fontface = parameters["fontface"] || "Helvetica";
        var fontsize = parameters["fontsize"] || 70;
	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	context.font = fontsize + "px " + fontface;

	// get size data (height depends only on font size)
	var metrics = context.measureText( message );
	var textWidth = metrics.width;


	// text color
        context.fillStyle = "yellow";

	context.fillText( message, 0, fontsize);

	// canvas contents will be used for a texture
	var texture = new THREE.Texture(canvas)
			texture.minFilter = THREE.LinearFilter;
			texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial({ map: texture, useScreenCoordinates: false});
	var sprite = new THREE.Sprite( spriteMaterial );
	return sprite;
}

function getMeterScale(sep,meters) {
    var scale = [];
    var n = meters/sep;
    for(var i = 0; i < n; i++) {
	scale.push(""+i*sep+"m");
    }
    return scale;
}

function gridInit(glScene,gDimensions){

    var tickSeparationMeters = 0.5;

    // Y is the vertical dimension!
    // x is width, z is distance away
    var data = {
  labels: {
      y: getMeterScale(tickSeparationMeters,gDimensions.h),
      x: getMeterScale(tickSeparationMeters,gDimensions.w),
    z: getMeterScale(tickSeparationMeters,gDimensions.d)
  }
};


      var graphDimensions = {
	  w:gDimensions.w,
	  d:gDimensions.d,
	  h:gDimensions.h
      };

	var boundingGrid = new THREE.Object3D(),
			depth = graphDimensions.d/2, //depth
			width = graphDimensions.w/2, //width
			height = graphDimensions.h/2, //height
			a =data.labels.y.length,
			b= data.labels.x.length,
			c= data.labels.z.length;

	//pink
	var newGridXY = createAGrid({
				height: width,
				width: height,
				linesHeight: b,
				linesWidth: a,
				color: 0xcc0000
			});
			//newGridXY.position.y = height;
    newGridXY.position.z = -depth;
    newGridXY.position.y = height;
			boundingGrid.add(newGridXY);

    //blue
	var newGridYZ = createAGrid({
				height: width,
				width: depth,
				linesHeight: b,
				linesWidth: c,
				color: 0x0000cc
			});
	 		newGridYZ.rotation.x = Math.PI/2;
//	 		newGridYZ.position.y = -height;
			boundingGrid.add(newGridYZ);

	//green
	var newGridXZ = createAGrid({
				height: depth,
				width: height,
				linesHeight:c,
				linesWidth: a,
				color: 0x00cc00
			});

    newGridXZ.position.x = width;
        newGridXZ.position.y = height;
			//newGridXZ.position.y = height;
	 		newGridXZ.rotation.y = Math.PI/2;
			boundingGrid.add(newGridXZ);

    glScene.add(boundingGrid);

    var margin = 0.4;
	var labelsW = labelAxis(width, data.labels.x,"x");
			labelsW.position.x = width;
			labelsW.position.y = 0;
    			labelsW.position.z = -margin + -depth;
			glScene.add(labelsW);

	var labelsH = labelAxis(height, data.labels.y,"y");
			labelsH.position.x = width;
                        labelsH.position.y = -margin/2;
			labelsH.position.z = -depth;
			glScene.add(labelsH);

	var labelsD = labelAxis(depth, data.labels.z, "z");
                        labelsD.position.x = width;
                        labelsD.position.y = 0;
			labelsD.position.z = -margin + depth;
			glScene.add(labelsD);
};


        </script>
</html>
