<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>gluss playground</title>
        <style>
            html, body {
                width: 100%;
                height: 100%;
                margin:0;
                padding:0;
                overflow: auto;
            }
	    .robscroll {
	    overflow: auto;
	    background: #fff;
	    }
        </style>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  </head>
    <body>
    <div id="container"></div>    
<!--     <div id="world"></div> 
    <div id="worldspace"></div> -->

    
    <div id="control" class="robscroll">
	<div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Control Graphical Interactions</h3>
	    <span class="pull-left clickable"><i class="glyphicon glyphicon-chevron-up"></i></span>
	  </div>
    <div class="panel-body">
    
	    <button id="gravity_ctl" type="button" onclick="toggle_gravity()" >
	      Turn Gravity Off    
	    </button>
	    <button id="auto_rectify_ctl" type="button" onclick="auto_rectify_toggle()" >
	      Turn Auto Rectify On
	    </button>
	    <button type="button" onclick="rectify()">
	      Rectify
	    </button>
	    <button type="button" onclick="disable_con()">
	      Disable Constraints On Manipulation
	    </button>
	    <button type="button" onclick="allow_con()">
	      Allow Constraints On Manipulation
	    </button>
	    <button type="button" onclick="step_con()">
	      Use STEP MODE
	    </button>
	    <button type="button" onclick="reset_to_default(gui,mw)">
	      Reset to Default
	    </button>
	    <button type="button" onclick="toggle_mouse_action()">
	      Toggle Mouse Cannon/Grab
	    </button>
    </div>
    </div>
	<div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Standard Poses</h3>
	    <span class="pull-left clickable"><i class="glyphicon glyphicon-chevron-up"></i></span>
	  </div>
	  <div class="panel-body">
	    <button type="button" onclick="big_size()">
	      Big size
	    </button>
	    <button type="button" onclick="small_size()">
	      Small size
	    </button>
	    <!-- These are currently not workin....
		 <button type="button" onclick="flat()">
		   Flat Pose
		 </button>
		 <button type="button" onclick="regenerate()">
		   Regenerate
		 </button>
		 -->
	  </div>
	</div>

	<!--
	    <textarea id="cli" rows="8" cols="80">
	      Imagine enterring a command here.
	    </textarea>
	    <button type="button" onclick="execute_code(this)">
	      Execute    
	    </button>
	    -->

	<div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Pose and Gait</h3>
	    <span class="pull-left clickable"><i class="glyphicon glyphicon-chevron-up"></i></span>
	  </div>
	  <div class="panel-body">
	    <button type="button" onclick="load_pose()">
	      Load Pose from JSON
	    </button>
	    
	    <span>
	      <button type="button" onclick="name_pose()">
		Name Pose
	      </button>
	      Pose Name:
	      <input id="posename" type="text" name="pose"><br>
    </span>
    Standard poses: <div id="stdposes"></div>
    Standard gaits: <div id="stdgaits"></div>    
	    My named poses: <div id="poslist"></div>
	    <span>
	      <button type="button" onclick="execute_gait()">
		Execute Gait
	      </button>
	      Gait:
	      <textarea id="gait" rows="8" cols="80"></textarea>
	    </span>
	  </div>
	</div>
	<div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">Robot Control</h3>
	    <span class="pull-left clickable"><i class="glyphicon glyphicon-chevron-up"></i></span>
	  </div>
	  <div class="panel-body">
            <button type="button" onclick="send_to_robot_url()">
	      Send Pose to Robot
	    </button>
	    Send Poses To URL:
	    <input id="poseurl" type="text" name="poseurl"><br>
	    <div id="robotcomresult">
	    </div>
	  </div>
	</div>	
	
	<div class="panel panel-default">
	  <div class="panel-heading">
	    <h3 class="panel-title">JSON Interactions</h3>
	    <span class="pull-left clickable"><i class="glyphicon glyphicon-chevron-up"></i></span>
	  </div>
	  <div class="panel-body">

<div>
	    <textarea id="pmodel" rows="8" cols="80">
	      The physcial model positions as JSON object will be rendered here.
	    </textarea>
            
            <textarea id="amodel" rows="8" cols="80">
	      The actuator positions as JSON object will be rendered here.
    </textarea>
    </div>
	  <div>  
	    <button type="button" onclick="render_physical_model(this)">
	      Render Physical    
	    </button>
	    <button type="button" onclick="render_actuator_model()">
	      Render Actuators
	    </button>
	    <button type="button" onclick="render_actuator_model('escaped')">
	      Render Actuators Esacped
	    </button>
</div>
	  </div>
	</div>
      </div>
    </body>

    <script src="./js/axes.js"></script>
    
    <script src="./js/three.js"></script>
    <script src="./js/ammo.js"></script>
    <script src="./js/OrbitControls.js"></script>    
    <script src="./js/Detector.js"></script>
    <script src="./js/stats.min.js"></script>    
    <script src="./js/cannon.js"></script>
    	<script src="./js/Projector.js"></script>	
    <script src="./js/STLLoader.js"></script>
    <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>    
   <script src="./js/d3-scale.min.js"></script>
   <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>

<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="https://d3js.org/d3-collection.v1.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-format.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-time.v1.min.js"></script>
<script src="https://d3js.org/d3-time-format.v2.min.js"></script>
<script src="https://d3js.org/d3-scale.v1.min.js"></script>

    
    <script src="./js/OrbitControls.js"></script>
     <script type="text/javascript" src="./js/dat.gui.js"></script> 
    <script>

function convert_to_number(obj) {
    for(var k in obj) {
	if (typeof obj[k] == "string") {
	    obj[k] = parseInt(obj[k]);
	}
    }
    return obj;
}

// A "robot" is really a graph of vertices with connections.
// In physical realization, the connections are actuators with length limits.
// In our first implementation, we will treat this as a set of springs in
// the cannon.js world...
// So in a sense we have 3 virtual worlds here: the abstract world
// of the robot, the cannon.js world of almost-physical objects, and
// the three.js world of meshes.
// This will be made slightly more confusing by utilizing Three.js
// and cannon.js utility classes (such as Vector) for convenience,
// even in the abstract world of the robot space.

// TODO: I hate global variables ---- I'd like to encapsulate this
// into a class.


// The MirroredWorld comtains both the Cannon world of physics
// and the Three.js world of renderable shapes and meshes.
var MW = function() {
    this.dt = 1/60;
    // Warning, this is a big of a hack --- it is unclear what should be used here.
    this.time_factor = 1.0;
    this.GROUND_PLANE_MESH;
    this.GROUND_BODY;
    this.meshes = [];
    this.bodies = [];
    this.cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xff5533, specular: 0x111111, shininess: 200, vertexColors: THREE.FaceColors } );



    // Okay, so we have a few problems here.  All parts of the robot should
    // interact with floor and the obstacles, but until we implement a prismatic joint,
    // we don't want the robots parts interacting with themselves.
    // So I will attempt to put the ground and obstacles in Group 1.
    // The go in Group2.  The robots filter group is "GROUP1".
    // The robots filter group is GROUP1 & GROUP2.

    // Collision filter groups - must be powers of 2!
    this.GROUP1 = 1;
    this.GROUP2 = 2;

    this.groundMaterial = new CANNON.Material("groundMaterial");
    
    this.global_friction = 1.0;
    
    // Adjust constraint equation parameters for ground/ground contact
    this.ground_ground_cm = new CANNON.ContactMaterial(this.groundMaterial, this.groundMaterial, {
	friction: this.global_friction,
	restitution: 0.8,
	contactEquationStiffness: 1e8,
	contactEquationRelaxation: 3,
	frictionEquationStiffness: 1e8,
	frictionEquationRegularizationTime: 3,
    });

    this.BASIC_BODY_MASS = 1; // This is kilograms.

    this.cworld;

    this.world_live = true;
    this.world_dead = false;

    this.CONSTRAINT_FORCE_SMALL = 1.0;
    this.CONSTRAINT_FORCE_LARGE = 10000.0;

    this.MEMBER_FRACTION = 20;

    // These things should actually be a part of the ROBOT, not the mirrored world!
    // These are in meters, measured joint-center to joint-center
    this.MAX_EDGE_LENGTH = 0.470;
    this.MIN_EDGE_LENGTH = 0.330;
    this.MEDIAN_EDGE_LENGTH = (this.MAX_EDGE_LENGTH + this.MIN_EDGE_LENGTH)/2;
    this.JOINT_RADIUS = 0.0508 / 2; // This is the 2" ball.

    this.MARKER_RADIUS = 0.1;


// This is sometimes useful for debugging.    
//    this.jointGeo = new THREE.BoxGeometry( this.JOINT_RADIUS*2,this.JOINT_RADIUS*2,this.JOINT_RADIUS*2);
    this.jointGeo = new THREE.SphereGeometry( this.JOINT_RADIUS,32,32);
    this.jointMaterial = new THREE.MeshPhongMaterial( { color: 0x0000ff } );

    this.playgroundDimensions = {
	w:10,
	d:10,
	h:3
    };

    this.am_playgroundDimensions = {
	w:10,
	d:10,
	h:3
    };

    this.INITIAL_HEIGHT = 0.3;
    this.Y_GRAVITY_FORCE = -9.8;

    
    this.robot = {
	robot_joints: [],
	robot_members: []
    };

    this.obstacles = [];
    this.obstacleSize = this.MEDIAN_EDGE_LENGTH*5;
    this.OBSTACLE_FRACTION = 30;
//    this.OBSTACLE_FRACTION = 3;
    this.OBSTACLE_MASS = 3;

    this.vector_up = new THREE.Vector3(0,0,1);
    this.vector_axis = new THREE.Vector3(0, 1, 0);

    this.floorTexture = new THREE.ImageUtils.loadTexture("images/logo-white-background.png");    
    this.ROBOT_PAIRINGS = null;

    this.most_recent_constraints;

    
};

MW.prototype.push_body_mesh_pair = function(body,mesh) {
    this.meshes.push(mesh);
    this.bodies.push(body);
}

MW.prototype.clear_non_floor_body_mesh_pairs = function() {
    mw.meshes = [];
    mw.bodies = [];
    mw.meshes.push(mw.GROUND_PLANE_MESH);
    mw.bodies.push(mw.GROUND_BODY);
    
}
MW.prototype.remove_robot = function() {
    mw.meshes = [];
    mw.bodies = [];
    mw.robot.robot_joints = [];
    mw.robot.robot_members = [];
}


var mw = new MW();

var GUI = function(mw) {
    this.PHYSICS_ENGINE = "CANNON";
    this.mw = mw;
    this.controls = null;
    this.SCREEN_WIDTH = window.innerWidth;
    this.SCREEN_HEIGHT = 1*window.innerHeight/2.0;
    this.TIME_BETWEEN_POSES_MS = 3000;
    this.GAIT_SUBDIVISIONS = 30;
    this.cameraOrtho = null;
    this.sceneOrtho = null;
    this.renderer = null;
    this.gplane=false;
    this.clickMarker=false;
    this.container = null;
    this.camera = null;
    this.scene = null;

    this.NUMBER_OF_TETRAHEDRA = 5;
//    this.NUMBER_OF_TETRAHEDRA = 1;

    this.jointBody = null;
    this.mouseConstraint = null;
    this.projector = null;
    this.grid_scene = null;
    this.am_grid_scene = null;    

    this.FORCE_REGIME = "DISABLE";

    this.gravity_on = true;
    this.world_container = $("#world");
    this.standard_objs;
    this.standard_ctx;
    this.url_for_robot = "http://127.0.0.1:9000";    
    this.auto_rectify_on = false;

    this.movedButNotSent = false;

    this.material = new THREE.MeshLambertMaterial( { color: 0x777777 } );
    this.markerMaterial = new THREE.MeshLambertMaterial( { color: 0xff0000 } );
    this.color_scale = d3.scale.quantile().domain([this.mw.MIN_EDGE_LENGTH, this.mw.MAX_EDGE_LENGTH])
    .range(['violet', 'indigo', '#8A2BE2', 'blue', 'green', 'yellow', '#FFD700', 'orange', '#FF4500']);


};


GUI.prototype.remove_world = function() {
    mw.world_live = false;
    while (gui.world_container.get()[0].hasChildNodes()) {   
	gui.world_container.get()[0].removeChild(gui.world_container.get()[0].firstChild);
    }

    mw.remove_robot();

    gui.jointBody = null;

    gui.mouseConstraint = null;

    gui.container = null;
    gui.camera = null;
    gui.scene = null;
    gui.renderer = null;
    gui.projector = null;

    gui.grid_scene = null;

    gui.cameraOrtho = null;
    
    sprite_controls.clear();
    
    gui.sceneOrtho = null;
    gui.gplane=false;
    gui.clickMarker=false;

    mw.meshes = [];
    mw.bodies = [];
    mw.GROUND_PLANE_MESH = null;
    mw.GROUND_BODY = null;
}


var gui = new GUI(mw);

function establish_controls(gui) {
    gui.controls = new THREE.OrbitControls( gui.camera, gui.container );
    gui.controls.enableDamping = true;
    gui.controls.dampingFactor = 0.25;
    gui.controls.enableZoom = true;
    gui.controls.enabled = true;

    var origin = new THREE.Vector3(0,0,0);
    gui.camera.lookAt(origin);
}

function addShadowedLight(scene, x, y, z, color, intensity ) {
    var directionalLight = new THREE.DirectionalLight( color, intensity );
    directionalLight.position.set( x, y, z );
    scene.add( directionalLight );
    directionalLight.castShadow = true;
    var d = 1;
    directionalLight.shadow.camera.left = -d;
    directionalLight.shadow.camera.right = d;
    directionalLight.shadow.camera.top = d;
    directionalLight.shadow.camera.bottom = -d;
    directionalLight.shadow.camera.near = 1;
    directionalLight.shadow.camera.far = 4;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.bias = -0.005;
}



function setClickMarker(gui,mw,x,y,z) {
    if(!gui.clickMarker){
        var shape = new THREE.SphereGeometry(mw.MARKER_RADIUS/4, 8, 8);
        gui.clickMarker = new THREE.Mesh(shape, gui.markerMaterial);
        gui.scene.add(gui.clickMarker);
    }
    gui.clickMarker.visible = true;
    gui.clickMarker.position.set(x,y,z);
    gui.movedButNotSent = true;
}
// TODO: This is not Ammo compatible!
function removeClickMarker(gui){
    gui.clickMarker.visible = false;
}


// This function creates a virtual movement plane for the mouseJoint to move in
function setScreenPerpCenter(point, gui) {
    // If it does not exist, create a new one
    if(!gui.gplane) {
	// We need to be precese about what these coordinates are!
        var planeGeo = new THREE.PlaneGeometry(4000,4000);
	// Something has change in three.js, apparently ray casting only
	// works with visible objects.  Since we are creating a plan to
	// move the joint in, I am going to try to create an object here that makes since.
	var plane_material = new THREE.MeshLambertMaterial( { color: 0x110000 } );
	plane_material.transparent = true;
	plane_material.opacity = 0.0;
	
	gui.gplane = new THREE.Mesh(planeGeo,plane_material);
	
        gui.scene.add(gui.gplane);
    }
    gui.gplane.visible = true;
    gui.gplane.name = "movementplane";
    gui.controls.enabled = false;

    // Center at mouse position
    gui.gplane.position.copy(point);

    // Make it face toward the camera
    gui.gplane.quaternion.copy(gui.camera.quaternion);
}


function projectOntoPlane(gui,screenX,screenY,thePlane,camera) {
    var x = screenX;
    var y = screenY;
    var now = new Date().getTime();
    // project mouse to that plane
    // This is probably highly wrong...
    // this means that we can only fold an object on itself.
    // I think this would work if you have
    var hit = findNearestIntersectingObject(gui,screenX,screenY,camera,[thePlane]);
    if(hit)
        return hit.point;
    else return false;
}
function findNearestIntersectingObject(gui,clientX,clientY,camera,objects) {
    var mouse3D = new THREE.Vector3( ( event.clientX / gui.renderer.getSize().width ) * 2 - 1,   //x
                                     -( event.clientY / (gui.renderer.getSize().height) ) * 2 + 1,  //y
                                     0.5 );                                            //z
    
    var mouse = new THREE.Vector2();
    mouse.x = (event.clientX / gui.renderer.getSize().width) * 2 - 1;
    mouse.y = -(event.clientY / (gui.renderer.getSize().height)) * 2 + 1; 

    var raycaster = new THREE.Raycaster();
    try {
	raycaster.setFromCamera(mouse, camera);
	var intersects = raycaster.intersectObjects( objects );        
	var closest = false;
	if (intersects.length > 0) {
            closest = intersects[0];
	}
	return closest;
    } catch (err) {
	console.log("Error: "+err);
	return null;
    }
}

function clear_text() {
    $("p").remove();
}
var sprite_controls = new function () {
    this.size = 50;
    this.sprite = 0;
    this.transparent = true;
    this.opacity = 0.6;
    this.colorize = 0xffffff;
    this.textcolor = "yellow";
    this.rotateSystem = true;

    this.clear = function (x,y) {
        gui.sceneOrtho.children.forEach(function (child) {
            if (child instanceof THREE.Sprite) gui.sceneOrtho.remove(child);
        })
    };

    this.draw_and_create = function (sprite,x,y,message) {
	var fontsize = 128;
	var ctx, texture,
	    spriteMaterial, 
	    canvas = document.createElement('canvas');
	ctx = canvas.getContext('2d');
	ctx.font = fontsize + "px Arial";

	// setting canvas width/height before ctx draw, else canvas is empty
	canvas.width = ctx.measureText(message).width;
	canvas.height = fontsize * 2; // fontsize * 1.5

	// after setting the canvas width/height we have to re-set font to apply!?! looks like ctx reset
	ctx.font = fontsize + "px Arial";        
	ctx.fillStyle = this.textcolor;        
	ctx.fillText(message, 0, fontsize);

	texture = new THREE.Texture(canvas);
	texture.minFilter = THREE.LinearFilter; // NearestFilter;
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial({
	    opacity: this.opacity,
	    color: this.colorize,
	    transparent: this.transparent,
	    map : texture});
	
	spriteMaterial.scaleByViewport = true;
	spriteMaterial.blending = THREE.AdditiveBlending;

        if (!sprite) {
	    sprite = new THREE.Sprite(spriteMaterial);
	}
	
	sprite.scale.set(this.size, this.size, this.size);
	sprite.position.set(x, y, 0);
	
	gui.sceneOrtho.add(sprite);
	return sprite;
    };
};





function get_member_color(len) {
    if (len < mw.MIN_EDGE_LENGTH)
	return d3.rgb("black");
    else if (len > mw.MAX_EDGE_LENGTH)
	return d3.rgb("black");
    else {
	var p = (len - mw.MIN_EDGE_LENGTH) / (mw.MAX_EDGE_LENGTH - mw.MIN_EDGE_LENGTH);
	return d3.rgb(gui.color_scale(len));
    }
}



function render(gui) {
    gui.renderer.render(gui.scene, gui.camera);
    gui.renderer.render(gui.grid_scene, gui.camera);
    gui.renderer.autoClear = false;
    // This is for the sprites....
    gui.renderer.render(gui.sceneOrtho, gui.cameraOrtho);
}


function add_obstacle(world,scene) {
    // Materials

    var num = 4;

    var positions = [{x:0,y:mw.INITIAL_HEIGHT,z:1},
			  {x:1,y:mw.INITIAL_HEIGHT,z:0},
			  {x:0,y:mw.INITIAL_HEIGHT,z:-1},
			  {x:-1,y:mw.INITIAL_HEIGHT,z:0}];
    for(var i = 0; i < num; i++) {
	var obstacleShape = new CANNON.Box(new CANNON.Vec3(
	    mw.obstacleSize/2,mw.obstacleSize/(2*mw.OBSTACLE_FRACTION),mw.obstacleSize/(2*mw.OBSTACLE_FRACTION)));
	
	OBSTACLE_BODY = new CANNON.Body({ mass: mw.OBSTACLE_MASS, material: mw.ground_ground_cm
					  ,
					  collisionFilterGroup: mw.GROUP1,
					  collisionFilterMask: mw.GROUP1 | mw.GROUP2, 
					});
	OBSTACLE_BODY.addShape(obstacleShape);

	OBSTACLE_BODY.name = "obstacle-"+i;
	OBSTACLE_BODY.structureKind = "obstacle";
	OBSTACLE_BODY.position.set(positions[i].x,positions[i].y,positions[i].z);
	OBSTACLE_BODY.angularDamping = 0.9;
	OBSTACLE_BODY.linearDamping = 0.9;

	var q = new THREE.Quaternion();
	var vector = new THREE.Vector3(positions[i].x,positions[i].y,positions[i].z);
	var axis = new THREE.Vector3(0,1,0);
	q.setFromAxisAngle(axis,i*(Math.PI/2.0));
	OBSTACLE_BODY.quaternion.set(q.x,q.y,q.z,q.w);
	

	world.addBody(OBSTACLE_BODY);
	mw.obstacles.push(OBSTACLE_BODY);

	var cubeGeo = new THREE.BoxGeometry( mw.obstacleSize,
					     mw.obstacleSize/mw.OBSTACLE_FRACTION,
					     mw.obstacleSize/mw.OBSTACLE_FRACTION );
	var mesh = new THREE.Mesh(cubeGeo, mw.cubeMaterial);
	mesh.name = "obstacle-"+i;
	mesh.structureKind = "obstacle";
	scene.add(mesh);

	mesh.geometry.verticesNeedUpdate = true;
	mesh.geometry.elementsNeedUpdate = true;        
	mesh.geometry.colorsNeedUpdate = true;

	mw.push_body_mesh_pair(OBSTACLE_BODY,mesh);

    }

    return [OBSTACLE_BODY,mesh];
}

function remove_non_eternal_constraints() {
/*    world.constraints.forEach(function (c) {
	if (!c["eternal"]) 
	    world.removeConstraint(c);
    });
*/
    am.robot.robot_members.forEach(function (c) {
	var cs = c.body.constraints;
	am.am_physicsWorld.removeConstraint(cs[0]);
	am.am_physicsWorld.removeConstraint(cs[1]);
    });

}

Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};


function vectorToString(v) {
    return "["+v.x+","+v.y+","+v.z+"]";
}

function ccw_tetrahelix_vertex(n,edge_length) {
    // TODO: memoize these functions.
    var r = (3 * Math.sqrt(3) / 10) * edge_length;
    var h = (1/Math.sqrt(10)) *edge_length;
    var theta = Math.acos(-2/3);
    // I want to make sure "B and C" land on the ground first!    
    var twist = 45*(Math.PI / 180.0);
    return new CANNON.Vec3( r * Math.cos(n*theta+twist),  r * Math.sin(n*theta+twist), n*h );
}

function add_member_spring(a,b,world) {
    var stiffness = 10;
    var damping = 0.3;
    restlength = a.position.distanceTo(b.position);
    
    var c = new CANNON.DistanceConstraint(a,b,restlength,mw.CONSTRAINT_FORCE_SMALL);
    world.addConstraint(c);
    
}


// To do a great job with this, we really need to know the
// range of possible values, but I'll fake it..
function alphabetic_name(n) {
    if (n < 26) {
	return String.fromCharCode(65+n);
    } else {
	if (n < 26*26) {
	    return alphabetic_name(Math.floor(n/26))+alphabetic_name(n % 26);
	} else {
	    return ""+n;
	}
    }
}

var joints_to_link_map = {};




function add_robot(cworld,scene) {
    var pvec = new CANNON.Vec3(0,mw.INITIAL_HEIGHT,0);
    
    load_NTetGlussBot(cworld,
		      gui.NUMBER_OF_TETRAHEDRA,
		      pvec);
    
    update_constraints(mw.robot.robot_members,
		       link => {
			   return mw.MEDIAN_EDGE_LENGTH;
		       });

}


// TODO: make world local here...
function initCannon(mw,gui){
    // Setup our world
    mw.cworld = new CANNON.World();
    // Add contact material to the world
    mw.cworld.addContactMaterial(mw.ground_ground_cm);
    
    mw.cworld.quatNormalizeSkip = 0;
    mw.cworld.quatNormalizeFast = false;

    mw.cworld.gravity.set(0,mw.Y_GRAVITY_FORCE,0);
    mw.cworld.broadphase = new CANNON.NaiveBroadphase();
    mw.cworld.broadphase = new CANNON.SAPBroadphase(mw.cworld);

    // Joint body
    var shape = new CANNON.Box(new CANNON.Vec3(mw.MARKER_RADIUS/2,mw.MARKER_RADIUS/2,mw.MARKER_RADIUS/2));
    gui.jointBody = new CANNON.Body({ mass: 0 });
    gui.jointBody.addShape(shape);
    gui.jointBody.collisionFilterGroup = 0;
    gui.jointBody.collisionFilterMask = 0;
    mw.cworld.addBody(gui.jointBody);
}

function add_floor(mw,gui) {
    var item = add_ground_plane(mw.cworld,gui.scene)
    mw.GROUND_PLANE_MESH = item[1];
    mw.push_body_mesh_pair(item[0],item[1]);
    gui.scene.add(mw.GROUND_PLANE_MESH);
}

function disable_con() {
    gui.FORCE_REGIME = "DISABLE";
}
function allow_con() {
    gui.FORCE_REGIME = "NONE";    
}
function step_con() {
    gui.FORCE_REGIME = "STEP";    
}

function toggle_mouse_action() {
    am.MOUSE_FIRES = !am.MOUSE_FIRES;
}

function step_con() {
		       }

function send_to_robot_url() {
    // Right now, we are just sending the current config
    var pmodel = extract_physical_node_model(am.robot);
    if (pmodel.length > 0) {
	
	var amx = model_to_actuator_space(pmodel,am.robot);
	var x = JSON.stringify(amx,null,2);
	console.log(x);
	gui.url_for_robot = $("#poseurl").val();
	console.log(x);
	$.ajax({url: gui.url_for_robot,
		crossDomain: true,
		beforeSend: function(xhr){xhr.setRequestHeader('Access-Control-Allow-Origin', '*');},
		data: x,
		success: function(result){
		    
		    $("#robotcomresult").html(result);
		},
		error: function (request, status, error) {
		    //		alert(request.responseText);
		}
	       });
    }

}
		       

function updateMouseConstraints(gui,body) {
    if (gui.PHYSICS_ENGINE == "CANNON") {
	// Now we want to disable all attached length constraints (and actually add others)
	mw.cworld.constraints.forEach(function (c) {
	    if (c.name != "mouseConstraint"){
		// Possibly we don't want to really disable these, but weaken them.
		if (gui.FORCE_REGIME == "STEP") {
		    var d = c.bodyA.position.distanceTo(c.bodyB.position);

		    var dp = Math.max(Math.min(d,mw.MAX_EDGE_LENGTH),mw.MIN_EDGE_LENGTH);
		    // r should be 1.0 when at the edge.

		    // NOTE: This approach is fundamentally limited, and probably conceptually wrong!
		    // The string of the spring should not increase as we exceed the length!!!
		    // THIS IS FUNDAMENTALLY WRONG.
		    var r = (d - mw.MEDIAN_EDGE_LENGTH)/ ((mw.MAX_EDGE_LENGTH - mw.MIN_EDGE_LENGTH)/ 2);

		    r = Math.max(r,0.4);
		    var f = mw.CONSTRAINT_FORCE_SMALL*Math.pow(r,2);
		    if (!c["eternal"]) 
			mw.cworld.removeConstraint(c);
		    var n = new CANNON.DistanceConstraint(c.bodyA,c.bodyB,dp,f);
		    world.addConstraint(n);

		} else if (gui.FORCE_REGIME == "DISABLE") {
		    if (((c.bodyA == body) || (c.bodyB == body))
			&& (!(c.bodyA.structureKind =="endpoint") || (c.bodyB.structureKind == "endpoint")) 
		       ) {
			
			c.disable();
		    }
		} else if (gui.FORCE_REGIME == "NONE") {
		}
	    }
	});
    } else {
    }
    
}

var global_o;

// There is a real problem here that body is either an Ammo body or a Cannon body!
function addMouseConstraint(gui,x,y,z,body) {
    // The cannon body constrained by the mouse joint

    if (gui.PHYSICS_ENGINE == "CANNON") {
	var constrainedBody = body;

	// Vector to the clicked point, relative to the body
	var v1 = new CANNON.Vec3(x,y,z).vsub(constrainedBody.position);

	// Apply anti-quaternion to vector to tranform it into the local body coordinate system
	var antiRot = constrainedBody.quaternion.inverse();
	var pivot = antiRot.vmult(v1); // pivot is not in local body coordinates

	// Move the cannon click marker particle to the click position
	// TODO: This set does NOT work in the AMMO world!  Must do something more complicated.

	gui.jointBody.position.set(x,y,z);
    } else if (gui.PHYSICS_ENGINE == "AMMO") {
	var constrainedBody = body;

	// Vector to the clicked point, relative to the body
//	var cm = constrainedBody.getCenterOfMassTransform();
	// Somehow I need to adjust the transform and reset....
//	var v1 = new Ammo.btVector3(x, y, z);

	// Apply anti-quaternion to vector to tranform it into the local body coordinate system

	
	gui.am_physicsWorld.removeRigidBody(gui.jointBody);

	var startTransform = new Ammo.btTransform();
	startTransform.setIdentity();
	startTransform.setOrigin(new Ammo.btVector3(x, y, z));
	gui.jointBody.setCenterOfMassTransform(startTransform);
	//	gui.jointBody.clearForces();
	gui.jointBody.setLinearVelocity(new Ammo.btVector3(0,0,0));
	gui.jointBody.setAngularVelocity(new Ammo.btVector3(0,0,0));
	gui.am_physicsWorld.addRigidBody(gui.jointBody);
    }

    updateMouseConstraints(gui,body);

    // Create a new constraint
    // The pivot for the gui.jointBody is zero
    if (gui.PHYSICS_ENGINE == "CANNON") {
	gui.mouseConstraint = new CANNON.PointToPointConstraint(constrainedBody, pivot, gui.jointBody, new CANNON.Vec3(0,0,0));
	gui.mouseConstraint.name = "mouseConstraint";
	gui.mouseConstraint.attachedBody = body;


	// Add the constriant to world
	mw.cworld.addConstraint(gui.mouseConstraint);
	// We want to turn gravity offf while we are editing....
	mw.cworld.gravity.set(0,0,0);
    } else if (gui.PHYSICS_ENGINE == "AMMO") {
	var markerBody = gui.jointBody;
	var constrainedBody = body;
	var startTransform = constrainedBody.getWorldTransform();
	var o = startTransform.getOrigin();

	var pivotInA = new Ammo.btVector3( 0, 0, 0 );;
	var pivotInB = new Ammo.btVector3( -(x-o.x()), -(y-o.y()), -(z-o.z()) );;
	global_o = new Ammo.btVector3( pivotInB.x(),
				       pivotInB.y(),
				       pivotInB.z() );
	
	var con = new Ammo.btPoint2PointConstraint(markerBody,
						   constrainedBody,
						   pivotInA,
						   pivotInB);
	gui.mouseConstraint = con;
	gui.mouseConstraint.attachedBody = constrainedBody;

	gui.am_physicsWorld.addConstraint(con, true);

    }
}




// This functions moves the transparent joint body to a new postion in space

function moveJointToPoint(gui,x,y,z) {
    if (gui.PHYSICS_ENGINE == "CANNON") {

	// Move the joint body to a new position
	gui.jointBody.position.set(x,y,z);

	var body = gui.mouseConstraint.attachedBody;
	
	var w = mw.MEDIAN_EDGE_LENGTH / mw.MEMBER_FRACTION;

	mw.bodies.forEach(function (bx,i) {
	    var bx = mw.bodies[i];
	    if (bx.structureKind == "member") {
		var a = bx.link_a;
		var b = bx.link_z;

		if ((a == body) || ( b == body)) {
		    // HERE is where we must deal with the mesh changing sizes, not in physics.
		    var ap = a.position;
		    var bp = b.position;
		    var len = ap.distanceTo(bp);
		    
		    var cd3 = d3.rgb(gui.color_scale(len));
		    
		    var d = len;
		    
		    var h = a.position.distanceTo(b.position);
		    var cubeGeo = new THREE.BoxGeometry( w,h,w );

		    var mesh = new THREE.Mesh(cubeGeo, mw.cubeMaterial);

		    gui.scene.remove(mw.meshes[i]);
		    gui.scene.add(mesh);
		    mw.meshes[i] = mesh;
		    for(var j = 0; j < mesh.geometry.faces.length; j++) {
    			mesh.geometry.faces[j].color.setStyle( gui.color_scale(d) );
		    }
		    
		    mesh.position.set(a.position.x,a.position.y,a.position.z);
		    mesh.castShadow = true;
		    mesh.receiveShadow = true;
		    
		    mesh.geometry.verticesNeedUpdate = true;
		    mesh.geometry.elementsNeedUpdate = true;        
		    mesh.geometry.colorsNeedUpdate = true;

		}
	    }
	});


	updateMouseConstraints(gui,null);
	gui.mouseConstraint.update();

    } else if (gui.PHYSICS_ENGINE == "AMMO") {
	// Apparently this got really messes things up in Ammo!
	// HACK : just guessing here...
	gui.am_physicsWorld.removeRigidBody(gui.jointBody);
	var startTransform = new Ammo.btTransform();
	startTransform.setIdentity();

	var n_o = new Ammo.btVector3(x,y,z);
	startTransform.setOrigin(n_o);

	// This is wrong...we ned to move x,y,z plus the inverse ...
	// or let the constraint handle!
	gui.jointBody.setWorldTransform(startTransform);


	
	gui.jointBody.setLinearVelocity(new Ammo.btVector3(0,0,0));
	gui.jointBody.setAngularVelocity(new Ammo.btVector3(0,0,0));

	var cbody = gui.mouseConstraint.attachedBody
	cbody.setLinearVelocity(new Ammo.btVector3(0,0,0));
	cbody.setAngularVelocity(new Ammo.btVector3(0,0,0));
	gui.am_physicsWorld.addRigidBody(gui.jointBody);
	gui.jointBody.setGravity(am.NO_GRAVITY);
    }
    
}

function render_constraints() {
    mw.cworld.constraints.forEach(function (c) {
	console.log("("+c.bodyA.name+","+c.bodyB.name+") = "+c.distance);
    });
}

// TODO: This is specific to CANNON
function removeJointConstraint(gui) {
    // Remove constriant from world
    if (!gui.mouseConstraint) {
	return;
    }
    if (gui.PHYSICS_ENGINE == "CANNON") {
	mw.cworld.removeConstraint(gui.mouseConstraint);
	// Now we want to disable all attached length constraints (and actually add others)

	var body = gui.mouseConstraint.attachedBody;
	if (body) {
	    mw.cworld.constraints.forEach(function (c) {
		var newrestlength = c.bodyA.position.distanceTo(c.bodyB.position);
		// HACK: This is an experiment...
		if (gui.auto_rectify_on) {
		    newrestlength = Math.max(Math.min(newrestlength,mw.MAX_EDGE_LENGTH),mw.MIN_EDGE_LENGTH);
		}
		c.distance = newrestlength;
		c.update();
		c.enable();
	    });
	}
	gui.mouseConstraint = false;

	// Turn gravity back on...
	// We want to turn gravity offf while we are editing....
	if (gui.gravity_on) {
	    mw.cworld.gravity.set(0,mw.Y_GRAVITY_FORCE,0);
	}
	update_constraints(mw.robot.robot_members,link => {
	    var a = link.a;
	    var b = link.b;
	    var d = a.position.distanceTo(b.position);
	    return d;
	});
    } else if (gui.PHYSICS_ENGINE == "AMMO") {
	gui.am_physicsWorld.removeConstraint(gui.mouseConstraint);
    }

}

function render_physical_model(id) {
    var pmodel = extract_physical_node_model(am.robot);
    var command = $("#pmodel").val(JSON.stringify(pmodel,null,2));
}

function send_pose_to_robot() {
    alert("Yes, I will send!");
}

// This is now rendering in an "emacs-ready" way --- that needs to be
// made clear.
function render_actuator_model(form) {
    var pmodel = extract_physical_node_model(am.robot);
    
    var am = model_to_actuator_space(pmodel,am.robot);
    var x = JSON.stringify(am,null,2);
    if (form === 'escaped')
	x = '"'+x.replace(/"/gi,'\\"')+'"';
    var command = $("#amodel").val(x);
}

// TODO: This can be better.
function get_body_by_name(name) {
    var retval;
    am.robot.robot_joints.forEach(function (bx) {
	if ((bx.structureKind != "member") && (bx.name != "floor")) {
	    if (bx.name == name) {
		retval = bx;
	    }
	}
    });
    return retval;
}

function set_constraints(am) {
    update_constraints(am.robot.robot_members,link => {
	var e = actuator_to_length(am[key]);	
	return e;
    });
    mw.most_recent_constraints = am;
}

function interp(x,y,frac) {
    return x + (y-x)*frac;
}
function find_link_body(a,b,members) {
    if (a.name > b.name) {
	var t = b;
	b = a;
	a = t;
    }
    for(var i = 0; i < members.length; i++) {
	var memBody = members[i];
	if ((memBody.a.name == a.name)
	    && (memBody.b.name == b.name)) {
	    return memBody;
	}
    }
}
function set_interp_constraints(am0,am1,frac) {
    remove_non_eternal_constraints();
    
    var links = [];
    for (var key in am0) {
	if (am1.hasOwnProperty(key)) {
	    var link  = find_bodies_from_actuator(key);
            var a = get_body_by_name(link[0]);
            var b = get_body_by_name(link[1]);
	    var oa = a.getWorldTransform().getOrigin();
	    var ob = b.getWorldTransform().getOrigin();
	    var d = oa.distance(ob);
	    
	    var body = find_link_body(a,b,am.robot.robot_members);
	    
	    links.push({a: a, b: b, k: key, body: body.body });
	}
    }
    update_constraints(links,link => {
	var a = link.a;
	var b = link.b;
	var key = link.k;
	var e = actuator_to_length(interp(am0[key],am1[key],frac));
	return e;
    });

    am.most_recent_contraints = am1;
}

function rectify(id) {
    var pmodel = extract_physical_node_model(am.robot);
    
    var am = model_to_actuator_space(pmodel,am.robot);

    for (var key in am) {
	if (am.hasOwnProperty(key)) {
	    am[key] = Math.min(Math.max(am[key],0),1023);
	}
    }
    set_constraints(am);
}

function load_pose(id) {
    var pose_string = $("#amodel").val();
    var unescaped = pose_string.replace(/\\\"/g,"\"");
    var actuator_model = JSON.parse(unescaped);
    set_constraints(actuator_model);
}

function name_pose(id) {
    var pmodel = extract_physical_node_model(am.robot);
    var am = model_to_actuator_space(pmodel,am.robot);
    var name = $("#posename").val();
    var pose = {};
    pose["type"] = "pose";
    pose["name"] = name;
    pose["geometry"] = "5TetGlussBot";
    pose["pose"] = am;
    console.log(pose);
    localStorage.setItem(name, JSON.stringify(am));
    update_poses();
}

function set_named_pose(id) {
    var pose = localStorage.getItem(localStorage.key(id));
    var constraints = JSON.parse(pose);
    execute(am.standard_ctx,am.most_recent_contraints,execute_atom,constraints.pose,am.GAIT_SUBDIVISIONS,am.TIME_BETWEEN_POSES_MS);
}
function set_standard_pose(num) {
    var pose = am.standard_objs[num];
    var constraints = pose.pose;
    execute(am.standard_ctx,am.most_recent_contraints,execute_atom,pose.pose,am.GAIT_SUBDIVISIONS,am.TIME_BETWEEN_POSES_MS);
}
function set_standard_gait(num) {
    var gait = am.standard_objs[num];
    execute(am.standard_ctx,am.most_recent_contraints,execute_atom,gait.gait,am.GAIT_SUBDIVISIONS,am.TIME_BETWEEN_POSES_MS);
}

// This is section implements the Gluss Programming Language 0.1 (GLPL). A program is called a GLOG.
// This should probably be broken out into a different file.  The basic concept
// is that GLPL is a valid JSON object.  Here is a BNF, although since this is in JSON
// we basically will do "parsing".
// <glog> ::= <array> | <object>
// <object> ::= <def> | <com>
// <def> ::= <pose> | <gait>
// <pose> ::= Object whose "type" is "pose" and has "pose" property | <string>
// <gait> ::= Object whose "type is "gait" and has "gait" property, which is a glog
// <array> ::= '[' <list> ']'
// <list> ::= <glog> | <list> , <glog>
// <com> ::= <string> | <ex-pose>
// <ex-pose> ::= object which does not have "name" as a property
// In other words, a GLOG is an array of GLOGs or an object, and an object pose or a gait,
// and a gait is a GLOG.  So this is a language with no conditionals, not input, no loops.
// Not that in when a <string> is a <pose>, it potentially must be resolvable by definitions
// some where else.
// Following the concept I learned back at Rice University in '86, the language has a "context"
// which is mainly a dictionary of known defintions for strings.  Execution can return a context
// which adds a defintion to the context.  All of this is easier in LISP, of course. In this case
// we will use an object that maps names to GLOGs as the context
// So the 0.1 version is really astounding simple.  The main thing we have to be able to do
// is to process it into an executable pose and the remainding GLOG.

// This function returns [first,rest] (meaning a two-element array, where rest may not be an atom)
// It guarantees that the first is a executable command or an defintion (and that rest coorectly
// takes into account the fact that the head of the glog might not be atomic.
// Note that the context is an object that maps names to definitions.

// So the equestion is should this return a pose?  I think yes---the goal here is
// that this function expands all the way to a pose.  If a string is found,
// it must be expanded in context, and the "rest" part properly filled out.
function get_first_executable(ctx,glog) {
    if (Array.isArray(glog)) {
	if (glog.length == 0) {
	    return [glog,[]];
	} else if (glog.length == 1) {
	    return get_first_executable(ctx,glog[0]);	    
	} else {
	    // Okay, so how to handle the resulting arg here is a little tricky....
	    var res = get_first_executable(ctx,glog[0]);
	    var rest = [];
	    rest[0] = res[0];
	    rest[1] = res[1].concat(glog.slice(1));
	    return rest;
	}
    } else { // So we are either a definition of a command, either way we just package and are done.
	// Now if we are a string, we look it up in the context and expand..
	if (typeof glog == "string") {
	    var def = ctx[glog];
	    if (typeof def == 'undefined') { // didn't find it,
		console.log("Couldn't find string in context:" + glog);
		console.log("Context:" + ctx);
	    } else {
		if (def.type == "pose") {
		    var rest = [];
		    rest[0] = def.pose;
		    rest[1] = [];
		} else if (def.type == "gait") {
		    var prog = def.gait; // This should be a glog!!
		    return get_first_executable(ctx,prog);
		}
		return rest;
	    }
	} else { // Presumably it is a pose, we should probably check that...
	    for(var k in glog) {
		var val = glog[k];
		var num;
		if (typeof val == "string") {
		    console.log("converting string to int: "+val);
		    num = parseInt(val);
		} else if (typeof val == "number")  {
		    num = val;
		} else {
		    console.log("Couldn't intepret: "+val);
		}
		// Possibly we should put a value test in here?
		glog[k] = num;
	    }
	    return [glog,[]];
	}
    }
}

// Real glogs have internal stucture we don't care about...so we can test with non-glogs..
function test_get_first_executable_0() {
    var ex0 = [[{A: 0},{A: 1}],[{A: 2}]];
    var res0 = get_first_executable(null,ex0);
    var f0 = res0[0];
    if (f0.A != 0)
	return false;
    var res1 = get_first_executable(null,res0[1]);
    var f1 = res1[0];
    if (f1.A != 1)
	return false;
    var res2 = get_first_executable(null,res1[1]);
    var f2 = res2[0];
    if (f2.A != 2)
	return false;
    if (res2[1].length != 0)
	return false;
    return true;
}

function glog_is_atom(glog) {
    return !(Array.isArray(glog));
}
function glog_is_definition(glog) {
    return (glog["type"] == "pose" || glog["type"] == "gait");
}
function glog_is_executable(glog) {
    return glog_is_atom(glog) && !glog_is_definition(glog);
}

function execute_atom(ctx,cur,atom,subdivisions,time_between_poses_ms) {
    var intertick = time_between_poses_ms / subdivisions;
    if (!cur) {
	cur = atom;
    }

    for(var j = 0; j < subdivisions; j++) {
	setTimeout(function(am0,am1,frac) {
	    set_interp_constraints(am0,am1,frac);
	},
	   j*intertick,
		   cur,
	   atom,
	   j/(subdivisions*1.0)
	  );
    }
}

function execute(ctx,initial,execute_atom,glog,subdivisions,time_between_poses_ms) {
    // if glog is an empty array or null, there is nothing to do.
    if (glog_is_atom(glog)) {
	if (glog_is_executable(glog)) {
	    execute_atom(ctx,initial,glog,subdivisions,time_between_poses_ms);
	}
    }
    var wait_time = time_between_poses_ms/subdivisions;
    var res0 = get_first_executable(ctx,glog);
    var first = res0[0];
    execute_atom(ctx,initial,first,subdivisions,time_between_poses_ms);
    var rest = res0[1];
    if (rest.length > 0) {
	setTimeout(function(r) {
	    execute(ctx,first,execute_atom,rest,subdivisions,time_between_poses_ms);
	},
		   time_between_poses_ms,
		   rest
		   );
    }
}
function execute_atom_dummy(ctx,glog) {
    console.log("atom"+glog);
}

function test_execute_0() {
    var glog = [{"A0":800,"A1":400,"A2":236,"A3":0,"A4":1000,"A5":0,"B0":500,"B1":500,"B2":1000,"B3":0,"B4":600,"B5":1000,"C0":200,"C1":1000,"C2":500,"C3":969,"C4":500,"C5":200},
		{"A0":800,"A1":400,"A2":236,"A3":500,"A4":1000,"A5":500,"B0":500,"B1":500,"B2":450,"B3":0,"B4":600,"B5":500,"C0":300,"C1":200,"C2":200,"C3":969,"C4":500,"C5":200}];
    execute(am.standard_objs,am.most_recent_contraints,execute_atom_dummy,glog,10,1000);
}

function test_execute_1() {
    var glog = [{"A0":800,"A1":400,"A2":236,"A3":0,"A4":1000,"A5":0,"B0":500,"B1":500,"B2":1000,"B3":0,"B4":600,"B5":1000,"C0":200,"C1":1000,"C2":500,"C3":969,"C4":500,"C5":200},
		{"A0":800,"A1":400,"A2":236,"A3":500,"A4":1000,"A5":500,"B0":500,"B1":500,"B2":450,"B3":0,"B4":600,"B5":500,"C0":300,"C1":200,"C2":200,"C3":969,"C4":500,"C5":200}];
    execute(am.standard_objs,am.most_recent_contraints,execute_atom,glog,10,1000);
}

function generate_context_from_standard(objects) {
    var ctx = {};
    for (var i = 0; i < objects.length; i++){
	var obj = objects[i];
	if (obj.type == "pose") {
	    ctx[obj.name] = obj;
	} else if (obj.type == "gait") {
	    ctx[obj.name] = obj;	    
	}
    }
    return ctx;
}


function test_execute_2() {
    var n0 = am.standard_objs[5].name;
    var n1 = am.standard_objs[6].name;
    var glog = [n0,n1];
    execute(am.standard_ctx,am.most_recent_contraints,execute_atom,glog,10,1000);
}

function test_execute_3() {
    var glog = ["thinwalk"];
    execute(am.standard_ctx,am.most_recent_contraints,execute_atom,glog,10,1000);
}

// The purpose of this is to return the context with more definitions...
function execute_definitions(ctx,glog) {
}



function update_poses() {
    var names = "";
    for (var i = 0; i < localStorage.length; i++){
	names += '<button type="button" onclick="set_named_pose('+i+')">' + localStorage.key(i) + '</button>';

    }
    $("#poslist").html(names);
}

function update_standard_poses() {
    var poses = "";
    var gaits = "";    
    for (var i = 0; i < am.standard_objs.length; i++){
	var obj = am.standard_objs[i];
	if (obj.type == "pose") {
	    poses += '<button type="button" onclick="set_standard_pose('+i+')">' + am.standard_objs[i].name + '</button>';
	} else if (obj.type == "gait") {
	    gaits += '<button type="button" onclick="set_standard_gait('+i+')">' + am.standard_objs[i].name + '</button>';
	}
    }
    $("#stdposes").html(poses);
    $("#stdgaits").html(gaits);    
}



// Need to expand this machinergy so that at any time we can process
// a pose or a gait mixed generically.

function execute_gait() {
    var gait = $("#gait").val();
    var pose_names = gait.trim().split(" ");
    var initial = get_first_executable(am.standard_ctx,pose_names[0]);
    execute(am.standard_ctx,initial[0],execute_atom,pose_names,am.GAIT_SUBDIVISIONS,am.TIME_BETWEEN_POSES_MS);
}

// Eventually this should be a linear interpolation of the models of frace from m1 to m2
function interpolate_model(m1,m2,frac) {
    console.assert(m1.length == m2.length,m1);
    var v = {};
    for (var key in m1) {
	if (m1.hasOwnProperty(key)) {
	    var iv = m1[key] + (m2[key] - m1[key])*frac;
	    v[key] = iv;
	}
    }
    console.log(v);
    return v;
}

function extract_physical_node_model(robot) {
    var nodes = [];
    robot.robot_joints.forEach( function (bx) {
	if ((bx.structureKind != "member") && (bx.name != "floor")) {
	    var o = bx.getWorldTransform().getOrigin();
	    nodes.push({ name: bx.name,
			 position: new THREE.Vector3(o.x(),o.y(),o.z()) });
	}
    });
    return nodes;
}

// Here I am developing some "poses" for fun.
// This may allow us to simulate a gait.
// This will require us to cross-reference the emacs-ctl.el file and
// begin integration with that.
// A pose exists in Actuator space rather than in cartesian space.
var lo = 0;
var mid = 450;
var hi = 900;

var flat_pose = { A0: 0, A1: 100+mid, A2: 100+mid, A3: 300+lo, A4: mid, A5: mid,
		  B0: 0, B1: 100+mid, B2: 100+mid, B3: 300+lo, B4: mid, B5: mid};

var actuator_to_length = d3.scale.linear().domain([0,1023]).range([mw.MIN_EDGE_LENGTH,mw.MAX_EDGE_LENGTH]);

function flat() {
    assume_pose(flat_pose);
}

// TODO: This is not using the argument --- something is terribly wrong.
function model_to_actuator_space(bodies,robot) {
    var pose = {};

    for(var lin in robot.robot_members) {
	var mem = robot.robot_members[lin];  
	var a = mem.a;
	var b = mem.b;
	// invert actually returns strings, for some reason, probably for css...
	// a.position will not be correct in the AMMO model...
	var oa = a.getWorldTransform().getOrigin();
	var ob = b.getWorldTransform().getOrigin();
	var d = oa.distance(ob);
	var d = parseInt(actuator_to_length.invert(d).toFixed(0));
	var actuator_name = find_actuator(a.name,b.name);
	pose[actuator_name] = d;
    }

    return pose;
}

function half_size() {
    factor_size(0.5);
}

function double_size() {
    factors_size(2.0);
}

function big_size() {
    fixed_size(am.MAX_EDGE_LENGTH);
}
function small_size() {
    fixed_size(am.MIN_EDGE_LENGTH);
}

// TODO: Can thse bee done with some sort of macro?
// NOTE: This is not AMMO ready.
function toggle_gravity() {
    if (am.gravity_on) {
	am.gravity_on = false;
	if (mw.cworld) {
	    mw.cworld.gravity.set(0,0,0);
	}
	if (am.am_physicsWorld) {
	    am.am_physicsWorld.setGravity( am.NO_GRAVITY );
	}
	$("#gravity_ctl").html("Turn Gravity On");
    } else {
	am.gravity_on = true;
	if (mw.cworld) {
	    mw.cworld.gravity.set(0,mw.Y_GRAVITY_FORCE,0);
	}
	if (am.am_physicsWorld) {
	    am.am_physicsWorld.setGravity( am.FULL_GRAVITY );
	}
	$("#gravity_ctl").html("Turn Gravity Off");
    }
}


function auto_rectify_toggle() {
    if (am.auto_rectify_on) {
	am.auto_rectify_on = false;
	$("#auto_rectify_ctl").html("Turn Auto Rectify On");	
    } else {
	am.auto_rectify_on = true;
	$("#auto_rectify_ctl").html("Turn Auto Rectify Off");	
    }
}

function update_constraints(links,f) {
    //    remove_non_eternal_constraints(mw.cworld);
    remove_non_eternal_constraints();
    for(var lin in links) {
	var link = links[lin];  
	var a = link.a;
	var b = link.b;
	if (a.name > b.name) {
	    var t = a;
	    a = b;
	    b = t;
	}
	var d = f(link);

	if (am.PHYSICS_ENGINE == "CANNON") {
	    var c = new CANNON.DistanceConstraint(a,b,d,mw.CONSTRAINT_FORCE_LARGE);
	    mw.cworld.addConstraint(c);
	    // now we want to find the Cannon Object associated with these links,
	    // and put a distance constraint between the member object and the two
	    // joint objects.
	    var mem = joints_to_link_map[a.name][b.name]
	    if (!mem) {
		console.log("Can't find a.name, b.name "+a.name + b.name);
	    }
	    var s = (d/2);
	    var memShape = mem.shapes[0];
	    memShape.halfExtents.set(s,
				     mw.MEDIAN_EDGE_LENGTH/(2*mw.MEMBER_FRACTION),
				     mw.MEDIAN_EDGE_LENGTH/(2*mw.MEMBER_FRACTION));
	    memShape.updateConvexPolyhedronRepresentation();
	    mem.computeAABB();
	    var pivotA = new CANNON.Vec3(0,0,0);

	    function add_p2p_constraint(a,mem) {
		var ca = new CANNON.PointToPointConstraint(a,pivotA,mem,0,mw.CONSTRAINT_FORCE_LARGE);
		mw.cworld.addConstraint(ca);
	    }

	    add_p2p_constraint(a,mem.endpoints[0]);
	    add_p2p_constraint(b,mem.endpoints[1]);
	} else if (am.PHYSICS_ENGINE == "AMMO") {
	    var memBody = link.body;
	    am.am_physicsWorld.removeConstraint(memBody.constraints[0]);
	    am.am_physicsWorld.removeConstraint(memBody.constraints[1]);	    	    
	    {
		var pivotInA = new Ammo.btVector3( 0, 0, 0 );
		var pivotInB = new Ammo.btVector3( d/2, 0, 0 );;
		var con = new Ammo.btPoint2PointConstraint(a,
							   memBody,
							   pivotInA,
							   pivotInB);
		am.am_physicsWorld.addConstraint(con, true);
	    }
	    {
		var pivotInA = new Ammo.btVector3( 0, 0, 0 );
		var pivotInB = new Ammo.btVector3( -d/2, 0, 0 );;
		var con = new Ammo.btPoint2PointConstraint(b,
							   memBody,
							   pivotInA,
							   pivotInB);
		am.am_physicsWorld.addConstraint(con, true);
	    }
	}
    }
}


function factor_size(f) {
    update_constraints(am.robot.robot_members,link => {
	var a = link.a;
	var b = link.b;
	var d = a.position.distanceTo(b.position);
	return d*f;
    });
}

function fixed_size(s) {
    update_constraints(am.robot.robot_members,link => {
	return s;
    });

}


function assume_pose(pose) {
    update_constraints(am.robot.robot_members,link => {
	var d = actuator_to_length(pose[act]);
	return d;
    });
    
    var STEPS_TO_TAKE = 30;
    for(var j = 0; j < STEPS_TO_TAKE; j++) {
	updatePhysics(mw);
    }
}


// To support bigger robots, I will have to allow numbering of these things.
// This patten can be repeated.  Basically we order the links in the order in
// which we fill in the nodes...
// Not that this CANNOT be fully regular, since we must adjust at the
// terminus based on the length, where we must break the patterns.
// An alternative pattern would be to make the first tetradra irregular.
// That is perhaps more sensible than what we have here.  Then each
// additional controller can be added in a completely regular way.


// These are now obsolete and must be removed!!

var ACTUATORS_PER_CONTROLLER = 6;
function actuator_name_from_number(n) {
    var controller = Math.floor(n / ACTUATORS_PER_CONTROLLER);
    var controller_name = alphabetic_name(controller);
    var digit = n % ACTUATORS_PER_CONTROLLER;
    return controller_name + digit;
}
function compute_body_number(name) {
    if (name.length > 1) {
	debugger;
    }
    return name.charCodeAt(0) - 65;
}

// return a pair of body names
function find_bodies_from_actuator(name) {
    var c = name.charCodeAt(0) - 65;
    var d = name.charCodeAt(1) - "0".charCodeAt(0);
    var n = ACTUATORS_PER_CONTROLLER * c + d;
    if (n < 6) {
	if (n == 0) {
	    return [alphabetic_name(0),alphabetic_name(1)];	    
	} else if (n == 1) {
	    return [alphabetic_name(0),alphabetic_name(2)];	    
	} else if (n == 2) {
	    return [alphabetic_name(0),alphabetic_name(3)];	    
	} else if (n == 3) {
	    return [alphabetic_name(1),alphabetic_name(2)];	    
	} else if (n == 4) {
	    return [alphabetic_name(2),alphabetic_name(3)];	    
	} else if (n == 5) {
	    return [alphabetic_name(3),alphabetic_name(1)];	    
	}
    } else {
	var hi = Math.floor((n - 6) / 3)+4;
	var lo = hi - (3 -  (n % 3));
    return [alphabetic_name(lo),alphabetic_name(hi)];
}

}
function test_find_bodies_from_actuator() {
    for(var i = 0; i < ACTUATORS_PER_CONTROLLER; i++) {
	var a = "A"+i;
	var bs = find_bodies_from_actuator(a);
	var ap = find_actuator(bs[0],bs[1]);
	if (ap != a) debugger;
    }
    
    for(var i = 0; i < ACTUATORS_PER_CONTROLLER; i++) {
	var a = "B"+i;
	var bs = find_bodies_from_actuator(a);
	var ap = find_actuator(bs[0],bs[1]);
	if (ap != a) debugger;
    }

    for(var i = 0; i < ACTUATORS_PER_CONTROLLER; i++) {
	var a = "G"+i;
	var bs = find_bodies_from_actuator(a);
	var ap = find_actuator(bs[0],bs[1]);
	if (ap != a) debugger;
    }

}

// a and b are node names.
function find_actuator(a,b) {
    if (a == b)
	debugger;

    if (b < a) {
	var t = a;
	a = b;
	b = t;
    }
    
    // Without loss of generality, a < b.
    var n;
    if (b <= "D") {
	if ((a == "A") && (b == "B")) {
	    n = 0; 
	} else if ((a == "A") && (b == "C")) {
	    n = 1;
	} else if ((a == "A") && (b == "D")) {
	    n = 2;
	} else if ((a == "B") && (b == "C")) {
	    n = 3;
	} else if ((a == "C") && (b == "D")) {
	    n = 4;
	} else if ((a == "B") && (b == "D")) {
	    n = 5;
	}
    } else {
	var k = compute_body_number(a);
	var h = compute_body_number(b);
	if ((h - k) > 3) {
	    debugger;
	}
	n = 3 * ( h - 2 ) + (3 - (h - k));
    }
    return actuator_name_from_number(n);
}

function test_find_actuator() {
    var x0 = find_actuator("A","B");
    if (x0 != "A0")
    {
	debugger;
    }
    var x1 = find_actuator("E","B");
    if (x1 != "B0") {
	debugger;
    }
    var x2 = find_actuator("E","C");
    if (x2 != "B1") {
	debugger;
    }
    var x3 = find_actuator("F","E");
    if (x3 != "B5") {
	debugger;
    }
}


// Compute the actuator name between the two 
function actuator(b1,b2) {
    return find_actuator(b1,b2);
}
/*
function build_world(gui,mw) {
    gui.scene = init_scene(gui);
    initCannon(mw,gui);
    add_floor(mw,gui);
    add_robot(mw.cworld,gui.scene);
    add_obstacle(mw.cworld,gui.scene);

    update_constraints(mw.robot.robot_members,
		       link => {
			   return mw.MEDIAN_EDGE_LENGTH;
		       });

    finish_scene_preparation(gui);
    update_poses();
    mw.world_live = true;
    animate(mw,gui);
}
*/


function reset_to_default(gui,mw) {
    gui.remove_world();
    build_world(gui,mw);
}

function initiation_stuff() {
    // TODO: Organize these into an init function.
    $(document).on('click', '.panel-heading span.clickable', function(e){
	var $this = $(this);
	if(!$this.hasClass('panel-collapsed')) {
	    $this.parents('.panel').find('.panel-body').slideUp();
	    $this.addClass('panel-collapsed');
	    $this.find('i').removeClass('glyphicon-chevron-up').addClass('glyphicon-chevron-down');
	} else {
	    $this.parents('.panel').find('.panel-body').slideDown();
	    $this.removeClass('panel-collapsed');
	    $this.find('i').removeClass('glyphicon-chevron-down').addClass('glyphicon-chevron-up');
	}
    });

    $("#poseurl").val(gui.url_for_robot);

    $.getJSON( "./standard_gaits.json")
	.done(function( json ) {
	    am.standard_objs = json;
	    am.standard_ctx = generate_context_from_standard(am.standard_objs);

	    var local_objs = [];
	    for (var i = 0; i < localStorage.length; i++){
		var obj = localStorage[localStorage.key(i)];
		var pobj = JSON.parse(obj);
		pobj["pose"] = convert_to_number(pobj["pose"])
		am.standard_ctx[localStorage.key(i)] = pobj;
	    }
	    update_standard_poses();	
	})
	.fail(function( jqxhr, textStatus, error ) {
	    var err = textStatus + ", " + error;
	    console.log( "Request Failed: " + err );
	});

    $('.panel-heading span.clickable').click();

//    build_world(gui,mw);

    // Initialize Three.js
    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
}

initiation_stuff();


// Here begins my attempt to integrate the AMMO.js port of the Bullet Physics engine


// Detects webgl
if ( ! Detector.webgl ) {
    Detector.addGetWebGLMessage();
    document.getElementById( 'container' ).innerHTML = "";
}

// - Global variables -

// This will have to be split later
var AM = function() {
    this.PHYSICS_ENGINE = "AMMO";
    this.am_container,
    this.am_stats;
    this.camera;
    this.controls;
    this.scene;
    this.renderer;
    this.am_textureLoader;
    this.am_clock = new THREE.Clock();
    this.am_clickRequest = false;
    this.am_mouseCoords = new THREE.Vector2();
    this.am_raycaster = new THREE.Raycaster();
    this.am_ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );
    this.am_pos = new THREE.Vector3();
    this.am_quat = new THREE.Quaternion();

    this.jointBody = null;

    this.playgroundDimensions = {
	w:10,
	d:10,
	h:3
    };
    this.GROUND_WIDTH = 1.0;

    this.gravity_on = true;
    
    // Physics variables
    this.am_gravityConstant = -9.8;

    this.NO_GRAVITY = new Ammo.btVector3( 0, 0, 0 );
    this.FULL_GRAVITY = new Ammo.btVector3( 0, this.am_gravityConstant, 0 )
    
    this.am_collisionConfiguration;
    this.am_dispatcher;
    this.am_broadphase;
    this.am_solver;
    this.am_physicsWorld;
    this.am_rigidBodies = [];
    this.am_softBodies = [];
    this.am_margin = 0.05;
    this.am_hinge;
    this.am_transformAux1 = new Ammo.btTransform();
    this.am_softBodyHelpers = new Ammo.btSoftBodyHelpers();

    this.am_armMovement = 0;

    //    this.am_window_height_factor = 1/4.0;
    this.am_window_height_factor = 0.5;
    // Sadly, this seems to do nothing!
    this.CAMERA_RADIUS_FACTOR = 1;

    this.am_grid_scene = null;
    // Used in manipulation of objects
    this.gplane=false;
    this.clickMarker=false;
    this.mouseConstraint = null;
    this.manipulatedObject = null;
    this.movedButNotSent = false;
    
    this.MOUSE_FIRES = false;

    this.INITIAL_HEIGHT = 0.3;

    this.meshes = [];

    this.NUMBER_OF_TETRAHEDRA = 5;
//    this.NUMBER_OF_TETRAHEDRA = 1;


    this.MARKER_MASS = 40;
    this.Y_GRAVITY_FORCE = -9.8;
    this.MARKER_RADIUS = 0.02;
    
    this.MEMBER_FRACTION = 20;

    // These things should actually be a part of the ROBOT, not the mirrored world!
    // These are in meters, measured joint-center to joint-center
    this.BASIC_BODY_MASS = 1; // This is kilograms.
    this.MEMBER_MASS = 1;
    this.MAX_EDGE_LENGTH = 0.470;
    this.MIN_EDGE_LENGTH = 0.330;
    this.MEDIAN_EDGE_LENGTH = (this.MAX_EDGE_LENGTH + this.MIN_EDGE_LENGTH)/2;
    this.JOINT_RADIUS = 0.0508 / 2; // This is the 2" ball.
    this.JOINT_MASS = 1;

    this.robot = {
	robot_joints: [],
	robot_members: []
    };

    this.standard_objs;
    this.standard_ctx;

// This is sometimes useful for debugging.    
//    this.jointGeo = new THREE.BoxGeometry( this.JOINT_RADIUS*2,this.JOINT_RADIUS*2,this.JOINT_RADIUS*2);
    this.jointGeo = new THREE.SphereGeometry( this.JOINT_RADIUS,32,32);
    this.jointMaterial = new THREE.MeshPhongMaterial( { color: 0x0000ff } );

}
AM.prototype.push_body_mesh_pair = function(body,mesh) {
    this.meshes.push(mesh);
    this.bodies.push(body);
}

AM.prototype.clear_non_floor_body_mesh_pairs = function() {
    this.meshes = [];
    this.bodies = [];
    this.meshes.push(mw.GROUND_PLANE_MESH);
    this.bodies.push(mw.GROUND_BODY);
    
}
AM.prototype.remove_robot = function() {
    this.meshes = [];
    this.bodies = [];
    this.robot.robot_joints = [];
    this.robot.robot_members = [];
}

var am = new AM();

// - Main code -

am_init();
am_animate();


// - Functions -

function am_init() {

    am_initGraphics();

    am_initHandlers();

    am_initPhysics();

    am_createGround(am);
    
    am_createObstacles();

    am_add_robot(am);

    am_initInput();

}

function am_add_robot(am) {
    var pvec = new CANNON.Vec3(0,am.INITIAL_HEIGHT,0);
    
    load_NTetGlussBot_Ammo(am,
		      am.NUMBER_OF_TETRAHEDRA,
		      pvec);
    
}

// I have a problem there that when you quit moving the mouse,
// the jointBody and constrainedBody both become detaches from
// the mouse---that is, their normal physics apply, EXCEPT
// for right when your move the mouse.  We could in theory
// disable the physics for the object until MouseUp.  I am not
// sure how to do this in Bullet.

function am_onMouseMove(e){

    // Move and project on the plane
    if (am.gplane && am.mouseConstraint) {

	var mouse3D = new THREE.Vector3( ( event.clientX / am.renderer.getSize().width ) * 2 - 1,   //x
					 -( event.clientY / (am.renderer.getSize().height) ) * 2 + 1,  //y
					 0.5 );                                            //z
		mouse3D.unproject( am.camera );

        var pos = projectOntoPlane(am,e.clientX,e.clientY,am.gplane,am.camera);
	
        if(pos){
            setClickMarker(am,mw,pos.x,pos.y,pos.z,am.scene);
            moveJointToPoint(am,pos.x,pos.y,pos.z);
        }
    }
}
// BUG: It is easy to get to constrainedBodies someone both constrained,
// But that is not the intention of the interaction tool, and is very annoying.
function am_onMouseDown(e){
    // Find mesh from a ray

    var mouse3D = new THREE.Vector3( ( e.clientX / am.renderer.getSize().width ) * 2 - 1,   //x
				     -( e.clientY / (am.renderer.getSize().height) ) * 2 + 1,  //y
				     0.5 );                                            //z
    mouse3D.unproject( am.camera );
    mouse3D.sub(am.camera.position);
    mouse3D.project( am.camera );
    
    var entity = findNearestIntersectingObject(am,e.clientX,e.clientY,am.camera,am.meshes);
    var pos = entity.point;
    // This is fragile, we need to be able to change this geometry....
    
    if (pos &&
	(
		(entity.object.structureKind == "obstacle")
		|| 
		(entity.object.structureKind == "joint")
		|| 
		(entity.object.structureKind == "member")
		)
       ){
        var idx = am.meshes.indexOf(entity.object);

	if (e.shiftKey) {
	    // If the shiftKey is down, we are going to toggle whether or not this one is fixed...
	    // and we will visually represent that by turning the joint red, I guess.
	    console.log(mw.bodies[idx]);
	    var b = mw.bodies[idx];
	    b.fixed_in_world = !b.fixed_in_world;
	    if (b.fixed_in_world) {
		b.mass = 0;
		entity.object.material.color.setHex( 0xff0000 );		
	    } else {
		b.mass = mw.BASIC_BODY_MASS;
		entity.object.material.color.setHex( 0x0000ff );				
	    }
		b.updateMassProperties();	    
	} else {
//            constraintDown = true;
            // Set marker on contact point
            setClickMarker(am,mw,pos.x,pos.y,pos.z,am.scene);

            // Set the movement plane
            setScreenPerpCenter(pos,am);


            if(idx !== -1){
		    if (am.PHYSICS_ENGINE == "CANNON") {
			console.log(" Internal error");
		    } else if (am.PHYSICS_ENGINE == "AMMO") {
			var obj = am.meshes[idx].ammo_obj;
			am.manipulatedObject = obj;
			obj.setGravity(am.NO_GRAVITY);			
			addMouseConstraint(am,pos.x,pos.y,pos.z,obj);		    }
            }
	}
    }
}

function am_onMouseUp(e) {
    // DEBUG Hack

	var mouse3D = new THREE.Vector3( ( event.clientX / am.renderer.getSize().width ) * 2 - 1,   //x
					 -( event.clientY / (am.renderer.getSize().height) ) * 2 + 1,  //y
					 0.5 );                                            //z
	
	mouse3D.unproject( am.camera );

       var pos = projectOntoPlane(am,e.clientX,e.clientY,am.gplane,am.camera);
        if(pos){
            setClickMarker(am,mw,pos.x,pos.y,pos.z,am.scene);
            moveJointToPoint(am,pos.x,pos.y,pos.z);
        }
    // remove the marker
    removeClickMarker(am);

    if (am.manipulatedObject) {
	am.manipulatedObject.setGravity(am.FULL_GRAVITY);
    }

    // Send the remove mouse joint to server
    removeJointConstraint(am);

    if (am.movedButNotSent) {
	send_to_robot_url();
	am.movedButNotSent = false;
    }
    
    if (am.gplane.visible == true) {
	am.gplane.visible = false;
	// We need to re-establish the controls because I don't have
	// any good way of exiting the active state...
	am.controls.dispose();
	establish_controls(am);
    }

}


function am_initHandlers() {
    am.am_container = document.getElementById( 'container' );
    am.am_container.addEventListener("mousemove", am_onMouseMove, true );
    am.am_container.addEventListener("mousedown", am_onMouseDown, true );
    am.am_container.addEventListener("mouseup", am_onMouseUp, true );
}


function am_initGraphics() {

    am.am_container = document.getElementById( 'container' );

    var PERSPECTIVE_FACTOR = 0.6;
    am.camera = new THREE.PerspectiveCamera( 60, window.innerWidth / (window.innerHeight * am.am_window_height_factor), PERSPECTIVE_FACTOR, 2000 );

    am.camera.aspect = window.innerWidth / (window.innerHeight * am.am_window_height_factor);

    var origin = new THREE.Vector3(0,0,0);
    am.camera.lookAt(origin);
    
//    am.camera.quaternion.setFromAxisAngle(new THREE.Vector3(0,1,0), (Math.PI/2));
    
    am.scene = new THREE.Scene();
    am.scene.fog = new THREE.Fog( 0x000000, 500, 10000 );    

    am.camera.position.x = -4;
    am.camera.position.y = 1;
    am.camera.position.z =  4;

    am.controls = new THREE.OrbitControls( am.camera, am.am_container );
    am.controls.target.y = 2;

    am.renderer = new THREE.WebGLRenderer( { antialias: true } );
    am.renderer.setClearColor( am.scene.fog.color );
    
    am.renderer.setPixelRatio( window.devicePixelRatio );
    am.renderer.setSize( window.innerWidth, window.innerHeight*am.am_window_height_factor );
    am.SCREEN_WIDTH = am.renderer.getSize().width;
    am.SCREEN_HEIGHT = am.renderer.getSize().height;
    am.camera.radius = ( am.SCREEN_WIDTH + am.SCREEN_HEIGHT ) / this.CAMERA_RADIUS_FACTOR;
    am.renderer.shadowMap.enabled = true;

    am.renderer.gammaInput = true;
    am.renderer.gammaOutput = true;

    am.am_textureLoader = new THREE.TextureLoader();

    var ambientLight = new THREE.AmbientLight( 0x404040 );
    am.scene.add( ambientLight );

    // lights
    var light, materials;
    am.scene.add( new THREE.AmbientLight( 0x666666 ) );
    am.scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

    addShadowedLight(am.scene, 1, 1, 1, 0xffffff, 1.35 );
    addShadowedLight(am.scene, 0.5, 1, -1, 0xffaa00, 1 );


    am.am_grid_scene = new THREE.Scene();
    am.am_grid_scene.fog = new THREE.Fog( 0x000000, 500, 10000 );    
    
    am.am_grid_scene.add( new THREE.AmbientLight( 0x666666 ) );
    
    light = new THREE.DirectionalLight( 0xffffff, 1.75 );
    var d = 20;

    light.position.set( -d, d, -d );

    light.castShadow = true;
    //light.shadow.CameraVisible = true;

    light.shadow.MapWidth = 1024;
    light.shadow.MapHeight = 1024;

    light.shadow.CameraLeft = -d;
    light.shadow.CameraRight = d;
    light.shadow.CameraTop = d;
    light.shadow.CameraBottom = -d;

    light.shadow.CameraFar = 3*d;
    light.shadow.CameraNear = d;
    light.shadow.Darkness = 0.5;
    
    am.am_grid_scene.add(light);
    am.scene.add(light);    
//    am_grid_scene.fog = new THREE.Fog( 0x000000, 500, 10000 );
    am.am_grid_scene.add( new THREE.AmbientLight( 0x666666 ) );    

    addShadowedLight(am.am_grid_scene, 1, 1, 1, 0xffffff, 1.35 );
    addShadowedLight(am.am_grid_scene, 0.5, 1, -1, 0xffaa00, 1 );
    
    // HACK:  These diemensions are probably not right here!
    gridInit(am.am_grid_scene,am.playgroundDimensions);
    
    am.am_container.innerHTML = "";

    am.am_container.appendChild( am.renderer.domElement );

//    am_stats = new Stats();
//    am_stats.domElement.style.position = 'absolute';
//    am_stats.domElement.style.top = '0px';
//    am_container.appendChild( am_stats.domElement );


    window.addEventListener( 'resize', am_onWindowResize, false );

}

function am_initPhysics() {

    // Physics configuration

    am.am_collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
    am.am_dispatcher = new Ammo.btCollisionDispatcher( am.am_collisionConfiguration );
    am.am_broadphase = new Ammo.btDbvtBroadphase();
    am.am_solver = new Ammo.btSequentialImpulseConstraintSolver();
    am.am_softBodySolver = new Ammo.btDefaultSoftBodySolver();
    am.am_physicsWorld = new Ammo.btSoftRigidDynamicsWorld( am.am_dispatcher, am.am_broadphase, am.am_solver, am.am_collisionConfiguration, am.am_softBodySolver);
    am.am_physicsWorld.setGravity( new Ammo.btVector3( 0,
						       am.gravity_on ? am.am_gravityConstant : 0,
						       0 ) );
    am.am_physicsWorld.getWorldInfo().set_m_gravity( new Ammo.btVector3( 0, am.am_gravityConstant, 0 ) );

    var material = new THREE.MeshPhongMaterial( { color: 0xFF0000 } );
    
    var pos = new Ammo.btVector3( 0, 0, 0 );
    var quat = new Ammo.btQuaternion( 0, 0, 0, 1 );

    // So we jort of want the jointbody to be non-kinematic, if that works with constraints.
    var mesh =  am_createParalellepiped( am.MARKER_RADIUS*2,
					 am.MARKER_RADIUS*2,
					 am.MARKER_RADIUS*2,
					 am.MARKER_MASS,
					 pos,
					 quat,
					 material );
    
    am.jointBody = mesh["ammo_obj"];
    am.jointBody.collisionFilterGroup = 0;
    am.jointBody.collisionFilterMask = 0;
    // This is a guess...
    // 
    // var DISABLE_SIMULATION = 4; 
    //am.jointBody.forceActivationState(DISABLE_SIMULATION)
}

function am_createObstacles() {

    var num = 4;


    var positions = [{x:0,y:mw.INITIAL_HEIGHT,z:1},
			  {x:1,y:mw.INITIAL_HEIGHT,z:0},
			  {x:0,y:mw.INITIAL_HEIGHT,z:-1},
			  {x:-1,y:mw.INITIAL_HEIGHT,z:0}];
    for(var i = 0; i < num; i++) {
	var pos = new THREE.Vector3();
	var quat = new THREE.Quaternion();
	var p = positions[i];
	pos.set( p.x, p.y, p.z);
        quat.set( 0, 0, 0, 1 );
	quat.setFromAxisAngle(new THREE.Vector3( 0, 1, 0 ), i * 90  * Math.PI / 180 )
	var material = new THREE.MeshPhongMaterial( { color: 0x33AAFF } );
	
	var mesh =  am_createParalellepiped( mw.obstacleSize,
					     mw.obstacleSize/mw.OBSTACLE_FRACTION,
					     mw.obstacleSize/mw.OBSTACLE_FRACTION,
					     mw.OBSTACLE_MASS,
					     pos,
					     quat,
					     material );
	mesh.castShadow = true;
	mesh.receiveShadow = true;
	mesh.name = "obstacle-"+i;
	mesh.structureKind = "obstacle";

	mesh["ammo_obj"].name = "obstacle-"+i;
	mesh["ammo_obj"].structureKind = "obstacle";
    }

}

function am_createGround(am) {
    // Ground
    // TODO: make these local!
    //    am.am_pos.set( 0, -GROUND_WIDTH/2, 0 );
    am.am_pos.set( 0, -am.GROUND_WIDTH/2, 0 );
    am.am_quat.set( 0, 0, 0, 1 );

    mw.floorTexture.wrapS = mw.floorTexture.wrapT = THREE.RepeatWrapping; 
    mw.floorTexture.repeat.set( 10, 10 );
    var floorMaterial = new THREE.MeshBasicMaterial( { map: mw.floorTexture, side: THREE.DoubleSide } );

    floorMaterial.transparent = true;
    floorMaterial.opacity = 0.7;

    var ground = am_createParalellepiped( am.playgroundDimensions.w, am.GROUND_WIDTH, 
					  am.playgroundDimensions.d,
					  0, am.am_pos, am.am_quat, floorMaterial );    
    ground.castShadow = true;
    ground.receiveShadow = true;
}

function am_processGeometry( bufGeometry ) {

    // Obtain a Geometry
    var geometry = new THREE.Geometry().fromBufferGeometry( bufGeometry );

    // Merge the vertices so the triangle soup is converted to indexed triangles
    var vertsDiff = geometry.mergeVertices();

    // Convert again to BufferGeometry, indexed
    var indexedBufferGeom = am_createIndexedBufferGeometryFromGeometry( geometry );

    // Create index arrays mapping the indexed vertices to bufGeometry vertices
    am_mapIndices( bufGeometry, indexedBufferGeom );

}

function am_createIndexedBufferGeometryFromGeometry( geometry ) {

    var numVertices = geometry.vertices.length;
    var numFaces = geometry.faces.length;

    var bufferGeom = new THREE.BufferGeometry();
    var vertices = new Float32Array( numVertices * 3 );
    var indices = new ( numFaces * 3 > 65535 ? Uint32Array : Uint16Array )( numFaces * 3 );

    for ( var i = 0; i < numVertices; i++ ) {

	var p = geometry.vertices[ i ];

	var i3 = i * 3;

	vertices[ i3 ] = p.x;
	vertices[ i3 + 1 ] = p.y;
	vertices[ i3 + 2 ] = p.z;

    }

    for ( var i = 0; i < numFaces; i++ ) {

	var f = geometry.faces[ i ];

	var i3 = i * 3;

	indices[ i3 ] = f.a;
	indices[ i3 + 1 ] = f.b;
	indices[ i3 + 2 ] = f.c;

    }

    bufferGeom.setIndex( new THREE.BufferAttribute( indices, 1 ) );
    bufferGeom.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

    return bufferGeom;
}

function am_isEqual( x1, y1, z1, x2, y2, z2 ) {

    var delta = 0.000001;
    return Math.abs( x2 - x1 ) < delta &&
	Math.abs( y2 - y1 ) < delta &&
	Math.abs( z2 - z1 ) < delta;

}

function am_mapIndices( bufGeometry, indexedBufferGeom ) {

    // Creates ammoVertices, ammoIndices and ammoIndexAssociation in bufGeometry

    var vertices = bufGeometry.attributes.position.array;
    var idxVertices = indexedBufferGeom.attributes.position.array;
    var indices = indexedBufferGeom.index.array;

    var numIdxVertices = idxVertices.length / 3;
    var numVertices = vertices.length / 3;

    bufGeometry.ammoVertices = idxVertices;
    bufGeometry.ammoIndices = indices;
    bufGeometry.ammoIndexAssociation = [];

    for ( var i = 0; i < numIdxVertices; i++ ) {

	var association = [];
	bufGeometry.ammoIndexAssociation.push( association );

	var i3 = i * 3;

	for ( var j = 0; j < numVertices; j++ ) {

	    var j3 = j * 3;
	    if ( am_isEqual( idxVertices[ i3 ], idxVertices[ i3 + 1 ],  idxVertices[ i3 + 2 ],
			  vertices[ j3 ], vertices[ j3 + 1 ], vertices[ j3 + 2 ] ) ) {
		association.push( j3 );
	    }

	}

    }

}

function am_createSoftVolume( bufferGeom, mass, pressure ) {

    am_processGeometry( bufferGeom );

    var volume = new THREE.Mesh( bufferGeom, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
    volume.castShadow = true;
    volume.receiveShadow = true;
    volume.frustumCulled = false;
    am.scene.add( volume );
    am.meshes.push( volume );

    am.am_textureLoader.load( "textures/colors.png", function( texture ) {
	volume.material.map = texture;
	volume.material.needsUpdate = true;
    } );

    // Volume physic object

    var volumeSoftBody = am.am_softBodyHelpers.CreateFromTriMesh(
	am.am_physicsWorld.getWorldInfo(),
	bufferGeom.ammoVertices,
	bufferGeom.ammoIndices,
	bufferGeom.ammoIndices.length / 3,
	true );

    var sbConfig = volumeSoftBody.get_m_cfg();
    sbConfig.set_viterations( 40 );
    sbConfig.set_piterations( 40 );

    // Soft-soft and soft-rigid collisions
    sbConfig.set_collisions( 0x11 );

    // Friction
    sbConfig.set_kDF( 0.1 );
    // Damping
    sbConfig.set_kDP( 0.01 );
    // Pressure
    sbConfig.set_kPR( pressure );
    // Stiffness
    volumeSoftBody.get_m_materials().at( 0 ).set_m_kLST( 0.9 );
    volumeSoftBody.get_m_materials().at( 0 ).set_m_kAST( 0.9 );

    volumeSoftBody.setTotalMass( mass, false )
    Ammo.castObject( volumeSoftBody, Ammo.btCollisionObject ).getCollisionShape().setMargin( am.am_margin );
    am_physicsWorld.addSoftBody( volumeSoftBody, 1, -1 );
    volume.userData.physicsBody = volumeSoftBody;
    // Disable deactivation
    volumeSoftBody.setActivationState( 4 );

    am_softBodies.push( volume );

}

function am_createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {

    var threeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );
    var shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
    shape.setMargin( am.am_margin );

    var body = am_createRigidBody( threeObject, shape, mass, pos, quat );
    
    threeObject["ammo_obj"] = body;
    return threeObject;

}

function am_createRigidBody( threeObject, physicsShape, mass, pos, quat ) {

    threeObject.position.copy( pos );
    threeObject.quaternion.copy( quat );

    var transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
    transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
    var motionState = new Ammo.btDefaultMotionState( transform );

    var localInertia = new Ammo.btVector3( 0, 0, 0 );
    physicsShape.calculateLocalInertia( mass, localInertia );

    var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
    var body = new Ammo.btRigidBody( rbInfo );

    threeObject.userData.physicsBody = body;

    am.scene.add( threeObject );
    am.meshes.push( threeObject );

    if ( mass > 0 ) {

	am.am_rigidBodies.push( threeObject );

	// Disable deactivation
	body.setActivationState( 4 );

    }

    am.am_physicsWorld.addRigidBody( body );

    return body;
}

function am_initInput() {
/*
    window.addEventListener( 'mousedown', function( event ) {

    	if ( ! am.am_clickRequest ) {

    	    am.am_mouseCoords.set(
    		( event.clientX / window.innerWidth ) * 2 - 1,
    		    - ( event.clientY / (window.innerHeight*am.am_window_height_factor) ) * 2 + 1
    	    );

    	    am.am_clickRequest = true;

    	}
    }, false );
*/
    
//    establish_controls(am);
    
}

function am_processClick() {
    if (!am.MOUSE_FIRES)
	return;

    if ( am.am_clickRequest ) {

	am.am_raycaster.setFromCamera( am.am_mouseCoords, am.camera );

	// Creates a ball
	var ballMass = 3;
	var ballRadius = 0.4;

	var ball = new THREE.Mesh( new THREE.SphereGeometry( ballRadius, 18, 16 ), am.am_ballMaterial );
	ball.castShadow = true;
	ball.receiveShadow = true;
	var ballShape = new Ammo.btSphereShape( ballRadius );
	ballShape.setMargin( am.am_margin );
	am.am_pos.copy( am.am_raycaster.ray.direction );
	am.am_pos.add( am.am_raycaster.ray.origin );
	am.am_quat.set( 0, 0, 0, 1 );
	var ballBody = am_createRigidBody( ball, ballShape, ballMass, am.am_pos, am.am_quat );
	ballBody.setFriction( 0.5 );

	am.am_pos.copy( am.am_raycaster.ray.direction );
	am.am_pos.multiplyScalar( 14 );
	ballBody.setLinearVelocity( new Ammo.btVector3( am.am_pos.x, am.am_pos.y, am.am_pos.z ) );

	am.am_clickRequest = false;

    }

}

function am_onWindowResize() {
    am.camera.aspect = window.innerWidth / (window.innerHeight * am.am_window_height_factor);
    am.renderer.setSize( window.innerWidth, window.innerHeight * am.am_window_height_factor );
    
    am.camera.updateProjectionMatrix();
    am.SCREEN_WIDTH = am.renderer.getSize().width;
    am.SCREEN_HEIGHT = am.renderer.getSize().height;
    am.camera.radius = ( am.SCREEN_WIDTH + am.SCREEN_HEIGHT ) / this.CAMERA_RADIUS_FACTOR;

    am.cameraOrtho = new THREE.OrthographicCamera( 0, am.SCREEN_WIDTH, am.SCREEN_HEIGHT, 0, - 10, 10 );    
}

function am_animate() {
    // Seems this is likely to be a problem...
    requestAnimationFrame( am_animate );
    am_render();
}

function am_render() {
    var deltaTime = am.am_clock.getDelta();
    am_updatePhysics( deltaTime );
    am_processClick();
    am.controls.update( deltaTime );

    // note this....

    am.renderer.render( am.scene, am.camera );
    am.renderer.autoClear = false;        
    am.renderer.render( am.am_grid_scene, am.camera);    
}

function am_updatePhysics( deltaTime ) {

    // Step world
    am.am_physicsWorld.stepSimulation( deltaTime, 10 );

    // Update soft volumes
    for ( var i = 0, il = am.am_softBodies.length; i < il; i++ ) {
	var volume = am.am_softBodies[ i ];
	var geometry = volume.geometry;
	var softBody = volume.userData.physicsBody;
	var volumePositions = geometry.attributes.position.array;
	var volumeNormals = geometry.attributes.normal.array;
	var association = geometry.ammoIndexAssociation;
	var numVerts = association.length;
	var nodes = softBody.get_m_nodes();
	for ( var j = 0; j < numVerts; j ++ ) {

	    var node = nodes.at( j );
	    var nodePos = node.get_m_x();
	    var x = nodePos.x();
	    var y = nodePos.y();
	    var z = nodePos.z();
	    var nodeNormal = node.get_m_n();
	    var nx = nodeNormal.x();
	    var ny = nodeNormal.y();
	    var nz = nodeNormal.z();

	    var assocVertex = association[ j ];

	    for ( var k = 0, kl = assocVertex.length; k < kl; k++ ) {
		var indexVertex = assocVertex[ k ];
		volumePositions[ indexVertex ] = x;
		volumeNormals[ indexVertex ] = nx;
		indexVertex++;
		volumePositions[ indexVertex ] = y;
		volumeNormals[ indexVertex ] = ny;
		indexVertex++;
		volumePositions[ indexVertex ] = z;
		volumeNormals[ indexVertex ] = nz;
	    }
	}

	geometry.attributes.position.needsUpdate = true;
	geometry.attributes.normal.needsUpdate = true;

    }

    // Update rigid bodies
    for ( var i = 0, il = am.am_rigidBodies.length; i < il; i++ ) {
	var objThree = am.am_rigidBodies[ i ];
	var objPhys = objThree.userData.physicsBody;
	var ms = objPhys.getMotionState();
	if ( ms ) {

	    ms.getWorldTransform( am.am_transformAux1 );
	    var p = am.am_transformAux1.getOrigin();
	    var q = am.am_transformAux1.getRotation();
	    objThree.position.set( p.x(), p.y(), p.z() );
	    objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

	}
    }

}


function load_NTetGlussBot_Ammo(am,tets,pvec) {

    // Okay, so here we need to create the geometry of the tetrahelix.
    // This could be done in a variety of ways.
    // Probably the most mathematical is to first define a vector
    // representing the center axis, and then use a formula the nth vertex.
    // Looks like some math as been worked out by R. W. Gray:
    // http://www.rwgrayprojects.com/rbfnotes/helix/helix01.html
    // I guess I will use a CounterClockWise (ccw) tetrahelix:
    // Vn = (r cos(n*theta), r sin(n*theta), n*h)

    var n = tets+3;    
    var mass = am.BASIC_BODY_MASS;

    for(var i = 0; i < n; i++) {
	var v = ccw_tetrahelix_vertex(i,am.MEDIAN_EDGE_LENGTH);
	v = v.vadd(pvec);

	var material = new THREE.MeshPhongMaterial( { color: 0xFF00FF } );

	var pos = new THREE.Vector3();
	var quat = new THREE.Quaternion();
	pos.set( v.x, v.y, v.z);
        quat.set( 0, 0, 0, 1 );
	var mesh =  am_createParalellepiped( am.JOINT_RADIUS*2,
					 am.JOINT_RADIUS*2,
					 am.JOINT_RADIUS*2,
					 am.JOINT_MASS,
					 pos,
					 quat,
					     material );
	
	mesh.castShadow = true;
	mesh.receiveShadow = true;
	am.scene.add(mesh);
	am.meshes.push(mesh);
	var body = mesh["ammo_obj"];
	body.name = alphabetic_name(i);
	body.structureKind = "joint";
	mesh.structureKind = "joint";	
	am.robot.robot_joints.push(body);

	for(var k = 0; k < Math.min(3,i) && k < i; k++) {
	    var h = i-(k+1);

	    // Sadly, increasing the mass of the members seems to be
	    // necessary to keep the edges from passing through the obstacles.
	    // This is a very unfortunate tuning...I suspect it is a weakness
	    // in the solver of physics engine.



	    var pos = new THREE.Vector3();
	    var quat = new THREE.Quaternion();

	    var b_z = am.robot.robot_joints[i];
	    var b_a = am.robot.robot_joints[h];
	    var o_a = b_a.getWorldTransform().getOrigin();
	    var o_z = b_z.getWorldTransform().getOrigin();	    
	    var v_z = new THREE.Vector3(o_a.x(),o_a.y(),o_a.z());
	    var v_a = new THREE.Vector3(o_z.x(),o_z.y(),o_z.z());
	    
	    var v_avg = v_z.add(v_a);
	    v_avg.multiplyScalar(0.5);
	    
	    pos.set( v_avg.x, v_avg.y, v_avg.z);
            quat.set( 0, 0, 0, 1 );
	    var mesh =  am_createParalellepiped(
		am.MEDIAN_EDGE_LENGTH,
		am.MEDIAN_EDGE_LENGTH/(am.MEMBER_FRACTION),
		am.MEDIAN_EDGE_LENGTH/(am.MEMBER_FRACTION),
		am.MEMBER_MASS,
		pos,
		quat,
		this.jointMaterial );
	
	    mesh.castShadow = true;
	    mesh.receiveShadow = true;
	    am.scene.add(mesh);
	    am.meshes.push(mesh);
	    var memBody = mesh["ammo_obj"];
	    memBody.structureKind = "member";
	    mesh.structureKind = "member";	    
	    memBody.link_a = b_a;
	    memBody.link_z = b_z;
	    if (b_a.name > b_z.name) {
		var t = b_a;
		b_a = b_z;
		b_z = t;
	    }
	    memBody.name = b_a.name + " " + b_z.name;
	    
	    var link = { a: b_a, b: b_z, body: memBody};
	    am.robot.robot_members.push(link);

	    var constraints = [];

	    {
		var pivotInA = new Ammo.btVector3( 0, 0, 0 );
		var pivotInB = new Ammo.btVector3( am.MEDIAN_EDGE_LENGTH/2, 0, 0 );;
		var con = new Ammo.btPoint2PointConstraint(b_a,
							   memBody,
							   pivotInA,
							   pivotInB);
		am.am_physicsWorld.addConstraint(con, true);
		constraints.push(con);
	    }
	    {
		var pivotInA = new Ammo.btVector3( 0, 0, 0 );
		var pivotInB = new Ammo.btVector3( -am.MEDIAN_EDGE_LENGTH/2, 0, 0 );;
		var con = new Ammo.btPoint2PointConstraint(b_z,
							   memBody,
							   pivotInA,
							   pivotInB);
		am.am_physicsWorld.addConstraint(con, true);
		constraints.push(con);		
	    }

	    var endpoints = [];
	    endpoints.push(b_a);
	    endpoints.push(b_z);
	    memBody["endpoints"] = endpoints;
	    memBody["constraints"] = constraints; 
	}

    }
}


        </script>
</html>
